% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}\usepackage[a4paper,bindingoffset=0.1in,left=1.0in,right=1.0in,top=1in,bottom=1.30in,footskip=.25in]{geometry}  
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{AFLOWpi Developers Guide}
\date{July 07, 2016}
\release{}
\author{Andrew Supka}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{plot module}
\label{plot:module-plot}\label{plot::doc}\label{plot:plot-module}\label{plot:welcome-to-aflowpi-s-documentation}\index{plot (module)}\index{\_\_bandPlot() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__bandPlot}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_bandPlot}}{\emph{oneCalc, yLim={[}-10, 10{]}, DOSPlot='`, LSDA=False, postfix='`, tight\_banding=False}}{}
Function to take the data files generated by the sumpdos ppBands functions and plots
the electronic band structure and the projected density of states with energy shifted
relative to the Fermi Energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{tuple}) -- Single calculation dictionary and the ID of the calculation
NEEDS TO BE CHANGED TO oneCalc,ID FORMAT SOON

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\item {} 
\textbf{DOSPlot} (\emph{str}) --
DOS or the PDOS plots next to the eletronic band structure plot (assuming you ran
either ppDOS or ppPDOS) (default: NONE)

\item {} 
\textbf{tight\_banding} (\emph{bool}) --
Whether to treat the input data as from Quantum Espresso or WanT bands.x

\item {} 
\textbf{postfix} (\emph{str}) --
Postfix to the filename of the plot

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_bands() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__bands}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_bands}}{\emph{oneCalc, ID, yLim={[}-10, 10{]}, DOSPlot='`, LSDA=False, postfix='`, tight\_banding=False}}{}
Wrapper function for AFLOWpi.plot.\_\_bandPlot
OBSOLETE. NEEDS REMOVAL
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- Single calculation that is the value of the dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of the calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\item {} 
\textbf{DOSPlot} (\emph{str}) --
DOS or the PDOS plots next to the eletronic band structure plot (assuming you ran
either ppDOS or ppPDOS) (default: NONE)

\item {} 
\textbf{postfix} (\emph{str}) --
Postfix to the filename of the plot

\item {} 
\textbf{tight\_banding} (\emph{bool}) --
Whether to treat the input data as from Quantum Espresso or WanT bands.x

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_distortionEnergy() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__distortionEnergy}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_distortionEnergy}}{\emph{calcs1}, \emph{xaxis}, \emph{yaxis}, \emph{zaxis='Energy'}, \emph{calcs=None}, \emph{colorbarUnits=None}, \emph{titleArray=None}, \emph{plotTitle=None}, \emph{xAxisStr=None}, \emph{yAxisStr=None}, \emph{fileName='distortionEnergy.pdf'}, \emph{percentage=False}}{}
Plots the change in energy of a certain chemistry when the structure is changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calcs1}} (\emph{dict}) -- calculations of calculations with which to compare calcs2 and calcs3 with

\item {} 
\textbf{\texttt{xaxis}} (\emph{str}) -- variable in the calculations you want as yaxis

\item {} 
\textbf{\texttt{yaxis}} (\emph{str}) -- variable in the calculations you want as yaxis

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{calcs} (\emph{list}) --
a set of calcs that has distorted parameters from calcs1 (default:None)

\item {} 
\textbf{title} (\emph{str}) --
title of plot (default:None)

\item {} 
\textbf{colorbarUnits} (\emph{str}) --
the units of the elements in the array.(default:same as xaxis)

\item {} 
\textbf{xaxisStr} (\emph{str}) --
The label for the horizontal axis of the plot.(default:same as yaxis)

\item {} 
\textbf{yaxisStr} (\emph{str}) --
The label for the vertical axis of the plot.(default:None)

\item {} 
\textbf{plotTitle (str) The title of the plot.(default} --
None)

\item {} 
\textbf{titleArray} (\emph{list}) --
an array for the labels for the colorbar for the sets (default:None)

\item {} 
\textbf{fileName} (\emph{str}) --
name (and path where default is directory where script is run from )
of the output file (default: `distortionEnergy.pdf')

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_dosPlot() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__dosPlot}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_dosPlot}}{\emph{oneCalc, ID, yLim={[}-10, 10{]}, LSDA=False}}{}
Function to take the data generated for the DOS and plot them with energy shifted relative to the Fermi Energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- Single calculation that is the value of the dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of the calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPath\_WanT() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__getPath_WanT}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_getPath\_WanT}}{\emph{oneCalc}, \emph{ID}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_plotByAtom() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__plotByAtom}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_plotByAtom}}{\emph{maxNum, speciesNum, fig, atom, oneCalc, ID, yLim={[}-10, 10{]}, LSDA=False, ax=None}}{}
Function to take the data files generated by the sumpdos function and
plots them with energy shifted relative to the Fermi Energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{atom}} (\emph{str}) -- Species of atom you are wanting to plot (`All' will
plot the combined pdos for all atoms in the system)

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- single calculation that is the value of the dictionary
of dictionaries of calculations

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{yLim} (\emph{list}) --
the limits of the ordinate on the plot (default: {[}-10,10{]}

\item[{Returns}] \leavevmode
\textbf{ax2} --
returns an axes object with the plotted proj. DOS

\item[{Return type}] \leavevmode
matplotlib.pyplot.axis

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_plot\_phonon() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__plot_phonon}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_plot\_phonon}}{\emph{oneCalc}, \emph{ID}, \emph{postfix='`}, \emph{THz=True}}{}
Function to take the data files generated by the sumpdos ppBands functions and plots the electronic band structure and the projected density of states with energy shifted relative to the Fermi Energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- Single calculation that is the value of the dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of the calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{postfix} (\emph{str}) --
Output filename postfix

\item {} 
\textbf{THz} (\emph{bool}) --
Plot the frequencies in THz or cm\textasciicircum{}-1

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_radialPDF() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__radialPDF}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_radialPDF}}{\emph{oneCalc}, \emph{ID}, \emph{atomNum}, \emph{filterElement=None}, \emph{title='`}, \emph{file\_prefix='`}, \emph{file\_postfix='`}, \emph{y\_range=None}, \emph{**kwargs}}{}
kwargs get passed onto the hist function inside

\end{fulllineitems}

\index{\_\_smoothGauss() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__smoothGauss}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_smoothGauss}}{\emph{list}, \emph{strippedXs=False}, \emph{degree=2}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_sumpdos() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__sumpdos}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_sumpdos}}{\emph{oneCalc}, \emph{ID}}{}
Takes the output files from projwfx.x that is called in the ppDOS function and sums
the projected orbitals across the files of each orbital for each atomic species
and outputs the summed data in files named \textless{}species\textgreater{}\_\textless{}orbital\textgreater{}.sumpdos.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of the calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_transport\_plot() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.__transport_plot}\pysiglinewithargsret{\code{plot.}\bfcode{\_\_transport\_plot}}{\emph{oneCalc}, \emph{ID}, \emph{nm=False}, \emph{postfix='`}}{}
Arguments:

Keyword Arguments:

\end{fulllineitems}

\index{bands() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.bands}\pysiglinewithargsret{\code{plot.}\bfcode{bands}}{\emph{calcs, yLim={[}-10, 10{]}, DOSPlot='`, LSDA=False, runlocal=False, postfix='`, tight\_banding=False}}{}
Generates electronic band structure plots for the calculations in the dictionary of dictionaries
of calculations with the option to have a DOS or PDOS plot to accompany it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\item {} 
\textbf{DOSPlot} (\emph{str}) --
DOS or the PDOS plots next to the eletronic band structure plot (assuming you ran
either ppDOS or ppPDOS) (default: NONE)

\item {} 
\textbf{postfix} (\emph{str}) --
Postfix to the filename of the plot

\item {} 
\textbf{tight\_banding} (\emph{bool}) --
Whether to treat the input data as from Quantum Espresso or WanT bands.x

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{distortionEnergy() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.distortionEnergy}\pysiglinewithargsret{\code{plot.}\bfcode{distortionEnergy}}{\emph{calcs1}, \emph{xaxis}, \emph{yaxis}, \emph{zaxis='Energy'}, \emph{calcs=None}, \emph{colorbarUnits=None}, \emph{titleArray=None}, \emph{plotTitle=None}, \emph{xAxisStr=None}, \emph{yAxisStr=None}, \emph{fileName='distortionEnergy.pdf'}, \emph{percentage=False}, \emph{runlocal=True}}{}
\end{fulllineitems}

\index{dos() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.dos}\pysiglinewithargsret{\code{plot.}\bfcode{dos}}{\emph{calcs, yLim={[}-10, 10{]}, LSDA=False, runlocal=False}}{}
Generates DOS plots for the calculations in the dictionary of dictionaries of calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\item {} 
\textbf{runlocal} (\emph{bool}) --
Do the plotting right now or if False do it when the calculations are running

\item {} 
\textbf{postfix} (\emph{str}) --
Postfix to the filename of the plot

\item {} 
\textbf{tight\_banding} (\emph{bool}) --
Whether to treat the input data as from Quantum Espresso or WanT bands.x

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{grid\_plot() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.grid_plot}\pysiglinewithargsret{\code{plot.}\bfcode{grid\_plot}}{\emph{calcs}, \emph{xaxis}, \emph{yaxis}, \emph{zaxis='Energy'}, \emph{colorbarUnits=None}, \emph{zaxis\_title=None}, \emph{plot\_title=None}, \emph{xAxisStr=None}, \emph{yAxisStr=None}, \emph{fileName='grid\_plot.pdf'}, \emph{runlocal=True}}{}
\end{fulllineitems}

\index{interpolatePlot() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.interpolatePlot}\pysiglinewithargsret{\code{plot.}\bfcode{interpolatePlot}}{\emph{calcs}, \emph{variable1}, \emph{variable2}, \emph{zaxis='Energy'}, \emph{xaxisTitle=None}, \emph{yaxisTitle=None}, \emph{zaxisTitle=None}, \emph{title=None}, \emph{fileName='interpolatePlot.pdf'}, \emph{delta=False}, \emph{text\_min=False}, \emph{vhline\_min=False}, \emph{circle\_min=False}, \emph{delta\_min=True}, \emph{rel\_center=False}, \emph{plot\_color='jet'}, \emph{find\_min=False}}{}
Takes a list of calculations and plots the energy of the calculations as a function of two input variables
the first value is the baseline for the energy value and the energy plotted is the difference between that
energy and the other energies in the grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{variable1}} (\emph{str}) -- a string of the variable in the calculations that you want as your x axis

\item {} 
\textbf{\texttt{variable2}} (\emph{str}) -- a string of the variable in the calculations that you want to your y axis

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{title} (\emph{str}) --
Title of plot (default: None)

\item {} 
\textbf{zaxis} (\emph{str}) --
Choice out of the keywords in each calc to plot in the Z axis (default: Energy)

\item {} 
\textbf{xaxisTitle} (\emph{str}) --
title of xaxis (default: same as variable1)

\item {} 
\textbf{yaxisTitle} (\emph{str}) --
title of yaxis (default: same as variable2)

\item {} 
\textbf{zaxisTitle} (\emph{str}) --
title of zaxis (default: same as zaxis)

\item {} 
\textbf{fileName} (\emph{str}) --
Name (and path where default is directory where script is run from ) of the
output file (default: `interpolatePlot.pdf')

\item {} 
\textbf{delta} (\emph{bool}) --
Z-axis scale relative to its first value

\item {} 
\textbf{delta\_min} (\emph{bool}) --
Z-axis scale relative to its lowest value

\item {} 
\textbf{text\_min} (\emph{bool}) --
Display text of minimum value next to the minimum value if find\_min=True

\item {} 
\textbf{vhline\_min} (\emph{bool}) --
Display text of minimum value next to the minimum value if find\_min=True

\item {} 
\textbf{circle\_min} (\emph{bool}) --
Display text of minimum value next to the minimum value if find\_min=True

\item {} 
\textbf{delta\_min} (\emph{bool}) --
Display text of minimum value next to the minimum value if find\_min=True

\item {} 
\textbf{rel\_center} (\emph{bool}) --
Display text of minimum value next to the minimum value if find\_min=True

\item {} 
\textbf{plot\_color} (\emph{str}) --
string of the matplotlib colormap to be used

\item {} 
\textbf{find\_min} (\emph{bool}) --
Interpolate between points and find value of
variable1 and variable2 for the minimum value of Z axis

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{interpolatePlot1D() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.interpolatePlot1D}\pysiglinewithargsret{\code{plot.}\bfcode{interpolatePlot1D}}{\emph{calcs}, \emph{variable1}, \emph{yaxis='Energy'}, \emph{xaxisTitle=None}, \emph{yaxisTitle=None}, \emph{title=None}, \emph{fileName='interpolatePlot.pdf'}, \emph{delta=False}, \emph{circle\_min=False}}{}
Takes a list of calculations and plots the energy of the calculations as a function of two input variables
the first value is the baseline for the energy value and the energy plotted is the difference between that
energy and the other energies in the grid
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{variable1}} (\emph{dict}) -- a string of the variable in the calculations that you want as your x axis

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yaxis} (\emph{str}) --
Choice out of the keywords in each calc to plot in the Z axis (default: Energy)

\item {} 
\textbf{xaxisTitle} (\emph{str}) --
title of xaxis (default: same as variable1)

\item {} 
\textbf{yaxisTitle} (\emph{str}) --
title of yaxis (default: same as yaxis)

\item {} 
\textbf{title} (\emph{str}) --
Title of plot (default: None)

\item {} 
\textbf{fileName} (\emph{str}) --
Name (and path where default is directory where script is run from ) of the
output file (default: `interpolatePlot.pdf')

\item {} 
\textbf{delta} (\emph{bool}) --
Z-axis scale relative to its first value

\item {} 
\textbf{circle\_min} (\emph{bool}) --
Display text of minimum value next to the minimum value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{opdos() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.opdos}\pysiglinewithargsret{\code{plot.}\bfcode{opdos}}{\emph{calcs, yLim={[}-10, 10{]}, LSDA=False, runlocal=False, postfix='`, scale=False}}{}
Generates electronic band structure plots for the calculations in the dictionary of dictionaries
of calculations with the option to have a DOS or PDOS plot to accompany it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
List or tuple of two integers for max and min range in horizontal axis of DOS plot

\item {} 
\textbf{LSDA} (\emph{bool}) --
To plot DOS as spin polarized or not (calculation must have been done as spin polarized)

\item {} 
\textbf{runlocal} (\emph{bool}) --
Do the plotting right now or if False do it when the calculations are running

\item {} 
\textbf{postfix} (\emph{str}) --
Postfix to the filename of the plot

\item {} 
\textbf{tight\_banding} (\emph{bool}) --
Whether to treat the input data as from Quantum Espresso or WanT bands.x

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{phonon() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.phonon}\pysiglinewithargsret{\code{plot.}\bfcode{phonon}}{\emph{calcs}, \emph{runlocal=False}, \emph{postfix='`}, \emph{THz=True}}{}
\end{fulllineitems}

\index{radialPDF() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.radialPDF}\pysiglinewithargsret{\code{plot.}\bfcode{radialPDF}}{\emph{calcs}, \emph{atomNum}, \emph{filterElement=None}, \emph{runlocal=False}, \emph{title='`}, \emph{**kwargs}}{}
kwargs get passed to pyplot.hist

\end{fulllineitems}

\index{read\_transport\_datafile() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.read_transport_datafile}\pysiglinewithargsret{\code{plot.}\bfcode{read\_transport\_datafile}}{\emph{ep\_data\_file}, \emph{mult\_x=1.0}, \emph{mult\_y=1.0}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{transport\_plots() (in module plot)}

\begin{fulllineitems}
\phantomsection\label{plot:plot.transport_plots}\pysiglinewithargsret{\code{plot.}\bfcode{transport\_plots}}{\emph{calcs}, \emph{runlocal=False}, \emph{postfix='`}}{}
\end{fulllineitems}



\chapter{prep module}
\label{prep:prep-module}\label{prep:module-prep}\label{prep::doc}\index{prep (module)}\index{ConfigSectionMap() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.ConfigSectionMap}\pysiglinewithargsret{\code{prep.}\bfcode{ConfigSectionMap}}{\emph{section}, \emph{option}, \emph{configFile=None}}{}
\end{fulllineitems}

\index{\_\_addToAll() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__addToAll}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_addToAll}}{\emph{calcs}, \emph{block=None}, \emph{addition=None}}{}
Adds text to a particular command block in the \_ID.py for all calculations
in the set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{block} (\emph{str}) --
the name of the command block that text will be added to

\item {} 
\textbf{addition} (\emph{str}) --
the text to be added to the block

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_addToBlock() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__addToBlock}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_addToBlock}}{\emph{oneCalc}, \emph{ID}, \emph{block}, \emph{addition}}{}
Writes the code to a single calculation's \_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{block}} (\emph{str}) -- string of the block in the \_ID.py that the addition is to be added to
for that step of workflow

\item {} 
\textbf{\texttt{addition}} (\emph{str}) -- a string containing code to be written to the specific block
in the \_ID.py for each calculation

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_announcePrint() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__announcePrint}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_announcePrint}}{\emph{string}}{}
A debugging tool used to accentuate a string os it can be easily picked out from stdout
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{string}} (\emph{str}) -- a string

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_calcsFromCalcList() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__calcsFromCalcList}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_calcsFromCalcList}}{\emph{calcList}}{}
Takes a list of dictionaries representing a calculation and turns the
list of dictionaries into a dictionary of dictionaries
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcList}} (\emph{list}) -- a list of dictionaries

\item[{Returns}] \leavevmode
A dictionary of dictionaries

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_checkSuccessCompletion() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__checkSuccessCompletion}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_checkSuccessCompletion}}{\emph{oneCalc}, \emph{ID}, \emph{faultTolerant=True}}{}
Allows one of the calculations to check the status of the other calculations
and returns True if all calculations in the set have completed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{faultTolerant} (\emph{bool}) --
a flag to choose if we return True if some of the
calculations ran but did not complete successfully

\item[{Returns}] \leavevmode
True if all calculations in the set are complete and False if not.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_check\_lock() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__check_lock}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_check\_lock}}{\emph{func}, \emph{oneCalc}, \emph{ID}, \emph{*args}, \emph{**kwargs}}{}
A function that is wrapped on another function to check if the script
has already run through to prevent certain functions in the \textless{}ID\textgreater{}.py
from running again after a restart or a loop like scfuj.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{func}} (\emph{func}) -- needed for the wrapper

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{*args}} -- additional arguments

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{**kwargs} --
additional keyword arguments

\item[{Returns}] \leavevmode
Returns either False or the calculation dictionary and its ID hash

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_check\_restart() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__check_restart}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_check\_restart}}{\emph{oneCalc}, \emph{ID}}{}
Not used. Delete possibly

\end{fulllineitems}

\index{\_\_cleanCalcs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__cleanCalcs}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_cleanCalcs}}{\emph{ID}, \emph{oneCalc}}{}
Removes all files from the directory tree with a ``\_'' prefix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_cleanInputStringSCF() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__cleanInputStringSCF}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_cleanInputStringSCF}}{\emph{inputString}}{}
Sanitizes QE input files by removing whitespace, commented out text, or any other
unnecessary characters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- a string of a QE input file

\item[{Returns}] \leavevmode
a string of the sanitized QE input file

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_copyConfig() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__copyConfig}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_copyConfig}}{\emph{config}, \emph{dest}}{}
Copies the config file used to the AFLOWpi directory when AFLOWpi
is initiated and resolves relative paths in the config file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{config}} (\emph{str}) -- location of the config file to be copied to ``AFLOWpi'' directory

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_crc64digest() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__crc64digest}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_crc64digest}}{\emph{aString}}{}
Generates the CRC64 hash checksum of the inputted string.

From W. H. Press, S. A. Teukolsky, W. T. Vetterling, and
B. P. Flannery, ``Numerical recipes in C
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{aString}} (\emph{str}) -- a string

\item[{Returns}] \leavevmode
\textbf{hashed\_str} --
a 16 character long CRC64 hash of the inputted string

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_fillTemplate() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__fillTemplate}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_fillTemplate}}{\emph{oneCalc}, \emph{ID}}{}
Fills in the blocks of each calculation's \_ID.py with mechanism for starting the next step in the chain
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_findInBlock() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__findInBlock}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_findInBlock}}{\emph{oneCalc}, \emph{ID}, \emph{block=None}, \emph{string='`}}{}
Looks for a string via a regular expression inside one of the command blocks in the \_ID.py.
Used to check before writing something as to avoid unintentionally having it written it twice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{block} (\emph{str}) --
a string of the name of the command block in the \_ID.py to look in.

\item {} 
\textbf{string} (\emph{str}) --
the string to search for which can be in plain text or as a regex.

\end{itemize}

\item[{Returns}] \leavevmode
True if the regex finds the pattern or False if it does not

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_forceSubmitNodeIP() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__forceSubmitNodeIP}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_forceSubmitNodeIP}}{\emph{nodeName}}{}
Creates the global variable \_\_submitNodeName\_\_ and gives it the value of nodeName
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{nodeName}} (\emph{str}) -- a string containing the name of the submit node

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_freezeAtoms() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__freezeAtoms}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_freezeAtoms}}{\emph{oneCalc}, \emph{ID}}{}
Modifies a QE input file to have all the atom movement flags in the ATOMIC\_POSITIONS
card be set to 0 which means they cannot move during a ionic or variable cell relax
calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
oneCalc object representing the calculation but with the flags for atom
movement all set to 0.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getAMass() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__getAMass}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_getAMass}}{\emph{atom}}{}
Get the atomic mass for the specific atomic species in input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{atom}} (\emph{str}) -- Atomic Species you want the mass of

\item[{Returns}] \leavevmode
Mass of the atom's species

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getLoglevel() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__getLoglevel}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_getLoglevel}}{}{}
Checks config file for loggings level.
If none specified it defaults to logging.INFO
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Returns}] \leavevmode

\textbf{loglevel} --
loglevel object associated with the logging
\begin{quote}

level string found in the config file
\end{quote}


\item[{Return type}] \leavevmode
logging.loglevel

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getNextOneCalcVarName() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__getNextOneCalcVarName}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_getNextOneCalcVarName}}{\emph{oneCalc}, \emph{ID}}{}
Gives increased the ID of one calculation an increase of one in its postfix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
the identical calculation object that was inputted and its ID that has had its ID modified

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPseudofilename() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__getPseudofilename}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_getPseudofilename}}{\emph{atom}, \emph{pseudodir='./PSEUDOs'}}{}
Gets the pseudopotential filename for the specific atomic species in input.
It will check in the AFLOWpi config file used when itiating the session for
a pseudodir path.

Species names must be in the form of the element's symbol possibly followed by integers
(i.e) ``O1'',''Co6'', or ``Sn165'' (Note that QE needs to be modified to accept species labels
longer than 3 characters. Instructions on how are in the engine\_mods directory.)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{atom}} (\emph{str}) -- a string designating the atomic species you want the pseudofile name for

\item[{Keyword Arguments}] \leavevmode
\textbf{pseudodir} (\emph{str}) --
the path of the directory containing pseudofiles

\item[{Returns}] \leavevmode

\textbf{pseudofilename} --
name of the pseudopotential file in for
\begin{quote}

that species in the pseudodir specified
\end{quote}


\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_hash64String() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__hash64String}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_hash64String}}{\emph{hashString}}{}
Takes a string and returns a 16 character long CRC64 hash checksum of it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{hashString}} (\emph{str}) -- the string you want a hash checksum of

\item[{Returns}] \leavevmode
\textbf{hashed\_str} --
a 16 character long CRC64 hash of the inputted string

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_incrementFileValue() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__incrementFileValue}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_incrementFileValue}}{\emph{oneCalc}, \emph{ID}, \emph{varName='uValue'}}{}
adds +1 to the value of a variable defined in the \_ID.py files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{varName} (\emph{str}) --
a string of the name of the variable that is to be incremented

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_loadCalcsFromOneCalc() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__loadCalcsFromOneCalc}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_loadCalcsFromOneCalc}}{\emph{oneCalc}, \emph{ID}}{}
Loads the entire calc set from one of the calculations at runtime. Used when all jobs in
a set are needed to perform a task (i.e plotting data from all calculations in the set)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
The dictionary of dictionaries representing the calculation set that oneCalc
is a part of

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_lock\_transform() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__lock_transform}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_lock\_transform}}{\emph{oneCalc}, \emph{ID}}{}
To be used with AFLOWpi.prep.newstepWrapper to stop a function from being run in the
\_\textless{}ID\textgreater{}.py python scripts generated by AFLOWpi to prohibit the wrapped function
from running if it has already run.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
a dictionary containing properties about the AFLOWpi calculation
ID (str): ID string for the particular calculation and step

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_modifyInputPrefixPW() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__modifyInputPrefixPW}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_modifyInputPrefixPW}}{\emph{oneCalc}, \emph{ID}}{}
Assigns the new prefix to a the calculation inputs in the form \_ID
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- The ID string for the particular calculation and the value of the the
prefix without the leading ``\_'' in front.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_modifyNamelistPW() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__modifyNamelistPW}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_modifyNamelistPW}}{\emph{oneCalc}, \emph{ID}, \emph{namelist}, \emph{parameter}, \emph{value}}{}
A Wrapper function that is used to write the function AFLOWpi.prep.\_\_modifyNameListPW
to the \_ID.py. If the value is intended to be a string in the QE input file, it must
be dually quoted i.e. value=```scf''' will become `scf' in the input file. If the value
is equal to None (without quotes) it will remove that parameter from the namelist.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{namelist}} (\emph{str}) -- a string of the fortran namelist that the parameter is in

\item {} 
\textbf{\texttt{parameter}} (\emph{str}) -- a string of the parameter name

\item {} 
\textbf{\texttt{value}} -- the value of that parameter

\end{itemize}

\item[{Returns}] \leavevmode
oneCalc object representing the calculation but with the paramater's value
changed or added in oneCalc{[}'\_AFLOWPI\_INPUT\_'{]} and the same ID as the input to
the function.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_modifyVarVal() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__modifyVarVal}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_modifyVarVal}}{\emph{oneCalc}, \emph{ID}, \emph{varName='uValue'}, \emph{value=None}}{}
Modifies the value of a variable defined in the \_ID.py files
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{varName} (\emph{str}) --
a string of the name of the variable that is to be changed

\item {} 
\textbf{value} --
the value to change it to in the \_ID.py

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_null\_\_() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__null__}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_null\_\_}}{\emph{*args}, \emph{**kwargs}}{}
\end{fulllineitems}

\index{\_\_num\_bands() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__num_bands}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_num\_bands}}{\emph{oneCalc}}{}
attempt to find the number of kohn-sham orbitals after the scf calculation to find
the value of the ``nbnd'' parameter in the ``\&system'' namelist of QE input files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item[{Returns}] \leavevmode
The value for the nbnd parameter in QE nscf calculations

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_parseRef() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__parseRef}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_parseRef}}{\emph{refFile}, \emph{dictFlag=False}}{}
Parses the input reference file and extract all of the information
it then organizes it in a standard way and is used to create a
unique hash checksum for the fortran namelist input. This is so spacing
and order of namelist input data will not affect the checksum of each
unique calculation input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{refFile}} (\emph{str}) -- a string of the input reference file

\item[{Keyword Arguments}] \leavevmode
\textbf{dictFlag} (\emph{bool}) --
whether you want to have a string of the cleaned up text or a
tokenized dictionary of it.

\item[{Returns}] \leavevmode
Dictionary or String

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_passGlobalVar() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__passGlobalVar}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_passGlobalVar}}{\emph{varname}, \emph{value}}{}
Used to define the value of a global variable in this module's global namesapce
usually from another module.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{varname}} (\emph{str}) -- name of the global variable

\item {} 
\textbf{\texttt{value}} -- value of the global variable

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_removeComments() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__removeComments}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_removeComments}}{\emph{inputString}}{}
Removes any text from a string that follows either a \# or ! on to the end of
that line.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- input string with ! or \# as comment characters

\item[{Returns}] \leavevmode
the same string with the comments removed

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_removeFromBlock() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__removeFromBlock}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_removeFromBlock}}{\emph{oneCalc}, \emph{ID}, \emph{block}, \emph{removal}}{}
Searches for a regular expression pattern inside a specific block of a each calculation's \_ID.py and
removes the command from the block.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{block}} (\emph{str}) -- string of the block in the \_ID.py that the addition is to be added to
for that step of workflow

\item {} 
\textbf{\texttt{removal}} (\emph{str}) -- a regular expression to find and delete a pattern of text in a single block
of each calculation's \_ID.py for a given step

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_resolveEqualities() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__resolveEqualities}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_resolveEqualities}}{\emph{inputString}}{}
Takes an input string that may or may not have text patterns of the form:

===EQN===

where EQN is some syntactically correct simple equations like 5+3. \_AFLOWpi keywords
can be used in the reference input. An example of this could be in to generate a set
of calculations used to make an energy map of one layer of a layered material sliding
across the other one might make their QE ATOMIC\_POSITIONS card in their reference
input like so:

ATOMIC\_POSTIONS \{crystal\}
\_AFLOWPI\_A\_ ===0.00+\_AFLOWPI\_XSHIFT\_===  ===0.00+\_AFLOWPI\_YSHIFT\_===  0.00
\_AFLOWPI\_A\_ ===0.50+\_AFLOWPI\_XSHIFT\_===  ===0.50+\_AFLOWPI\_YSHIFT\_===  0.00
\_AFLOWPI\_A\_ ===0.00+\_AFLOWPI\_XSHIFT\_===  ===0.00+\_AFLOWPI\_YSHIFT\_===  0.00
\_AFLOWPI\_A\_ ===0.50+\_AFLOWPI\_XSHIFT\_===  ===0.50+\_AFLOWPI\_YSHIFT\_===  0.00
\_AFLOWPI\_A\_ 0.00                     0.00                     0.75
\_AFLOWPI\_A\_ 0.00                     0.50                     0.75
\_AFLOWPI\_A\_ 0.50                     0.00                     0.75
\_AFLOWPI\_A\_ 0.50                     0.50                     0.75

With their user script containing a range of values for \_AFLOWPI\_XSHIFT\_ and \_AFLOWPI\_YSHIFT\_.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- a string of text

\item[{Returns}] \leavevmode
a string of text that has the equations (i.e. ===EQN===) replaced with values

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_temp\_executable() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__temp_executable}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_temp\_executable}}{\emph{oneCalc}, \emph{ID}, \emph{from\_step=0}}{}
Creates the \_ID.py for a single calculation for a given step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Keyword Argument}] \leavevmode
ext (str): an optional postfix to the ID's to all calculations in the set for a given step

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The one calculation for the new set, its ID, the old calculation, and its ID

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_transformInput() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__transformInput}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_transformInput}}{\emph{inputString}}{}
Standardizes the input format of the QE input files so AFLOWpi only has to account
for one standard input type for atomic positions and lattice parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- a string of a QE input file

\item[{Returns}] \leavevmode
\textbf{inputString} --
a string of a QE input file

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_transformParamsInput() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__transformParamsInput}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_transformParamsInput}}{\emph{inputString}}{}
Transforms the various styles of defining the lattice vectors into celldm form so AFLOWpi
has a standard format to work with.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- a string of a QE input

\item[{Returns}] \leavevmode
a string of a QE input that has its lattice vectors in celldm style

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_transformPositionsInput() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__transformPositionsInput}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_transformPositionsInput}}{\emph{inputString}}{}
Transforms the various styles of defining the atomic positions into crystal
fractional coordinates form so AFLOWpi has a standard format to work with.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- a string of a QE input

\item[{Returns}] \leavevmode
\textbf{inputString} --
a string of a QE input that has its atomic positions in crystal fractional coordinates

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_unfreezeAtoms() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__unfreezeAtoms}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_unfreezeAtoms}}{\emph{oneCalc}, \emph{ID}}{}
Modifies a QE input file to have all the atom movement flags in the ATOMIC\_POSITIONS
card be set to 1 which means they are allowed to move during a ionic or variable cell
relax calculation which is default in QE.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
object representing the calculation but with the flags for atom
movement all set to 1.

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_updatecalclogs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__updatecalclogs}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_updatecalclogs}}{\emph{calcs}, \emph{inc=True}}{}
Save the log for aflowkeys
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{aflowkeys}} (\emph{dict}) -- keys from aflow

\item {} 
\textbf{\texttt{calcs}} -- Dictionary of dictionaries of calculations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeLoggingBlock() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__writeLoggingBlock}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_writeLoggingBlock}}{\emph{oneCalc}, \emph{ID}, \emph{logfile}}{}
Writes the mechism to start the logging at runtime in the \_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{logfile}} (\emph{str}) -- string of the path of the logfile within the directory tree for that set of calculations

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeTemplate() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__writeTemplate}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_writeTemplate}}{\emph{finp}}{}
Writes the blocks of the skeleton \_ID.py to file for one calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{finp}} (\emph{str}) -- filepath for skeleton \_ID.py file to go

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeToScript() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__writeToScript}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_writeToScript}}{\emph{executable}, \emph{oneCalc}, \emph{ID}, \emph{from\_step=0}}{}
Generates calls on several functions to set up everything that is
needed for a new step in the workflow. AFLOWpi.prep.writeToScript loops
over the calculation set and calls this function to do the work on
each calculation in the set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{executable}} (\emph{str}) -- \textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\item {} 
\textbf{\texttt{*args}} -- \textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{**kwargs} --
\textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\item[{Returns}] \leavevmode
A single calculation dictionary for a new step and its ID.

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_write\_scratch\_meta\_data\_file() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.__write_scratch_meta_data_file}\pysiglinewithargsret{\code{prep.}\bfcode{\_\_write\_scratch\_meta\_data\_file}}{\emph{oneCalc}, \emph{ID}}{}
Not used. Delete possibly

\end{fulllineitems}

\index{addToBlockWrapper() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.addToBlockWrapper}\pysiglinewithargsret{\code{prep.}\bfcode{addToBlockWrapper}}{\emph{oneCalc}, \emph{ID}, \emph{block}, \emph{addition}}{}
Wraps AFLOWpi.prep.\_\_addToBlock for use inside \_calcs\_container methods
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{block}} (\emph{str}) -- string of the block in the \_ID.py that the addition is to be added to
for that step of workflow

\item {} 
\textbf{\texttt{addition}} (\emph{str}) -- a string containing code to be written to the specific block
in the \_ID.py for each calculation

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{askAFLOWpiVars() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.askAFLOWpiVars}\pysiglinewithargsret{\code{prep.}\bfcode{askAFLOWpiVars}}{\emph{refAFLOWpiVars}}{}
Cycle on the keys of the refAFLOWpiVars dictionary and ask to define them
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{refAFLOWpiVars}} (\emph{dict}) -- the variables in the ref files that you need to input to run the calculation

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{bands() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.bands}\pysiglinewithargsret{\code{prep.}\bfcode{bands}}{\emph{calcs}, \emph{dk=None}, \emph{nk=None}}{}
Wrapper function to write the function AFLOWpi.prep.\_\_oneBands to the \_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{dk} (\emph{float}) --
distance between points for Electronic Band Structure calculation

\item {} 
\textbf{nk} (\emph{int}) --
approximate number of k points to be calculated along the path

\end{itemize}

\item[{Returns}] \leavevmode
The identical ``calcs'' input variable

\end{description}\end{quote}

\end{fulllineitems}

\index{bandsAflow() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.bandsAflow}\pysiglinewithargsret{\code{prep.}\bfcode{bandsAflow}}{\emph{dk}, \emph{LAT}}{}
Query aflow for band structure path and generate the path for band structure calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dk}} (\emph{float}) -- distance between k points along path in Brillouin Zone

\item {} 
\textbf{\texttt{LAT}} (\emph{int}) -- bravais lattice number from Quantum Espresso convention

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{info} --
some information
nks (str): number of k points in path
stringk (str): kpoint path string

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{build\_calcs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.build_calcs}\pysiglinewithargsret{\code{prep.}\bfcode{build\_calcs}}{\emph{PARAM\_VARS}, \emph{build\_type='product'}}{}
\end{fulllineitems}

\index{calcFromFile() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcFromFile}\pysiglinewithargsret{\code{prep.}\bfcode{calcFromFile}}{\emph{aflowkeys}, \emph{fileList}, \emph{reffile=None}, \emph{pseudodir=None}, \emph{build=True}, \emph{workdir=None}, \emph{keep\_name=False}, \emph{clean\_input=True}}{}
Reads in a string of an QE input file path, a string of an QE input, a file object of a
QE input or a list of them and attempts to fill create a calculation from them. If they
are missing things such as k\_points card, they are automtically generated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{aflowkeys}} (\emph{dict}) -- a dictionary generated by AFLOWpi.prep.init

\item {} 
\textbf{\texttt{fileList}} (\emph{list}) -- a string of an QE input file path, a string of an QE input, a file
object of a QE input or a list of them

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{reffile} (\emph{str}) --
a partially filled QE input file used in case the input(s) in fileList
are missing. i.e. wfc cutoff. If the names of the Pseudopotential files
are not included in the input(s) in fileList, they are chosen depending
on the pseudodir chosen and included when the calculation set is formed.

\item {} 
\textbf{workdir} (\emph{str}) --
a string of the workdir path that be used to override what is in the
config file used when initating the AFLOWpi session

\item {} 
\textbf{pseudodir} (\emph{str}) --
a string of the pseudodir path that be used to override what is in
the config file used when initating the AFLOWpi session

\item {} 
\textbf{build} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{calcs\_container (class in prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container}\pysiglinewithargsret{\strong{class }\code{prep.}\bfcode{calcs\_container}}{\emph{dictionary}}{}~\index{addToAll() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.addToAll}\pysiglinewithargsret{\bfcode{addToAll}}{\emph{block=None}, \emph{addition=None}}{}
\end{fulllineitems}

\index{bands() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.bands}\pysiglinewithargsret{\bfcode{bands}}{\emph{dk=None}, \emph{nk=100}}{}
Wrapper method to write call AFLOWpi.prep.bands for calculating the Electronic Band
Structure.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{dk} (\emph{float}) --
the density in the Brillouin zone of the k point sampling along the
entirety of the path between high symmetry points.

\item {} 
\textbf{nk} (\emph{int}) --
the approximate number of sampling points  in the Brillouin Zone along
the entirety of the path between high symmetry points. Points are
chosen so that they are equidistant along the entirety of the path.
The actual number of points will be slightly different than the
inputted value of nk. nk!=None will override any value for dk.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{change\_input() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.change_input}\pysiglinewithargsret{\bfcode{change\_input}}{\emph{namelist=None}, \emph{parameter=None}, \emph{value=None}}{}
\end{fulllineitems}

\index{change\_pseudos() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.change_pseudos}\pysiglinewithargsret{\bfcode{change\_pseudos}}{\emph{directory}}{}
\end{fulllineitems}

\index{conventional\_cell\_input() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.conventional_cell_input}\pysiglinewithargsret{\bfcode{conventional\_cell\_input}}{}{}
\end{fulllineitems}

\index{crawl\_min() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.crawl_min}\pysiglinewithargsret{\bfcode{crawl\_min}}{\emph{mult\_jobs=False}, \emph{grid\_density=10}, \emph{initial\_variance=0.02}, \emph{thresh=0.01}, \emph{constraint=None}, \emph{final\_minimization='relax'}}{}
Wrapper method to call AFLOWpi.pseudo.crawlingMinimization in the high level user interface.
Adds a new step to the workflow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the \_calcs\_container object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{mult\_jobs} (\emph{bool}) --
if True split the individual scf jobs into separate cluster jobs
if False run them serially

\item {} 
\textbf{grid\_density} (\emph{int}) --
controls the number of calculations to generate for the minimization
num\_\{calcs\}=grid\_density\textasciicircum{}\{num\_\{parameters\}-num\_\{constraints\}\}

\item {} 
\textbf{initial\_variance} (\emph{float}) --
amount to vary the values of the parameters from the initial
value. i.e. (0.02 = +/-2\% variance)

\item {} 
\textbf{thresh} (\emph{float}) --
threshold for \$DeltaX\$ of the lattice parameters between brute force
minimization iterations.

\item {} 
\textbf{constraint} (\emph{list}) --
a list or tuple containing two entry long list or tuples with
the first being the constraint type and the second the free
parameter in params that its constraining for example in a
orthorhombic cell: constraint=({[}''volume'','c'{]},) allows for A and B
to move freely but C is such that it keeps the cell volume the same
in all calculations generated by the input oneCalc calculation.

\item {} 
\textbf{final\_minimization} (\emph{str}) --
calculation to be run at the end of the brute force minimization
options include ``scf'', ``relax'', and ``vcrelax''

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{dos() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.dos}\pysiglinewithargsret{\bfcode{dos}}{\emph{kpFactor=2}, \emph{project=True}}{}
Wrapper method to call AFLOWpi.prep.doss in the high level user interface.
Adds a new step to the workflow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the \_calcs\_container object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{kpFactor} (\emph{float}) --
factor to which the k-point grid is made denser in each direction

\item {} 
\textbf{project} (\emph{bool}) --
if True: do the projected DOS after completing the DOS

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{evCurve\_min() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.evCurve_min}\pysiglinewithargsret{\bfcode{evCurve\_min}}{\emph{pThresh=25}, \emph{final\_minimization='relax'}}{}
\end{fulllineitems}

\index{get\_initial\_inputs() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.get_initial_inputs}\pysiglinewithargsret{\bfcode{get\_initial\_inputs}}{}{}
\end{fulllineitems}

\index{increase\_step() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.increase_step}\pysiglinewithargsret{\bfcode{increase\_step}}{\emph{func}}{}
\end{fulllineitems}

\index{items() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.items}\pysiglinewithargsret{\bfcode{items}}{}{}
\end{fulllineitems}

\index{iteritems() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.iteritems}\pysiglinewithargsret{\bfcode{iteritems}}{}{}
\end{fulllineitems}

\index{keys() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
\end{fulllineitems}

\index{new\_step() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.new_step}\pysiglinewithargsret{\bfcode{new\_step}}{\emph{update\_positions=True}, \emph{update\_structure=True}, \emph{new\_job=True}, \emph{ext='`}}{}
\end{fulllineitems}

\index{phonon() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.phonon}\pysiglinewithargsret{\bfcode{phonon}}{\emph{nrx1=2}, \emph{nrx2=2}, \emph{nrx3=2}, \emph{innx=2}, \emph{de=0.01}, \emph{mult\_jobs=False}, \emph{raman=False}, \emph{LOTO=False}, \emph{disp\_sym=True}, \emph{atom\_sym=True}, \emph{field\_strength=0.01}}{}
\end{fulllineitems}

\index{pseudo\_test\_brute() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.pseudo_test_brute}\pysiglinewithargsret{\bfcode{pseudo\_test\_brute}}{\emph{ecutwfc}, \emph{dual={[}{]}}, \emph{sampling={[}{]}}, \emph{conv\_thresh=0.01}, \emph{constraint=None}, \emph{initial\_relax=None}, \emph{min\_thresh=0.01}, \emph{initial\_variance=0.05}, \emph{grid\_density=7}, \emph{mult\_jobs=False}, \emph{options=None}}{}
\end{fulllineitems}

\index{relax() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.relax}\pysiglinewithargsret{\bfcode{relax}}{}{}
\end{fulllineitems}

\index{resubmit() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.resubmit}\pysiglinewithargsret{\bfcode{resubmit}}{\emph{reset=True}}{}
\end{fulllineitems}

\index{scf() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.scf}\pysiglinewithargsret{\bfcode{scf}}{}{}
\end{fulllineitems}

\index{scfuj() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.scfuj}\pysiglinewithargsret{\bfcode{scfuj}}{\emph{thresh=0.1}, \emph{nIters=20}, \emph{paodir=None}, \emph{relax='scf'}, \emph{mixing=0.0}}{}
Wrapper method to call AFLOWpi.scfuj.scfPrep and AFLOWpi.scfuj.run in the high level
user interface. Adds a new step to the workflow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the \_calcs\_container object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{thresh} (\emph{float}) --
threshold for self consistent hubbard U convergence

\item {} 
\textbf{niters} (\emph{int}) --
max number of iterations of the acbn0 cycle

\item {} 
\textbf{paodir} (\emph{string}) --
the path of the PAO directory. This will override
an entry of the paodir in the AFLOWpi config file
used for the session

\item {} 
\textbf{mixing} (\emph{float}) --
the amount of the previous acbn0 U iteration to mix into
the current (only needed when there is U val oscillation)

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{split\_chain() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.split_chain}\pysiglinewithargsret{\bfcode{split\_chain}}{\emph{update\_positions=True}, \emph{update\_structure=True}}{}
\end{fulllineitems}

\index{submit() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.submit}\pysiglinewithargsret{\bfcode{submit}}{}{}
\end{fulllineitems}

\index{transport() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.transport}\pysiglinewithargsret{\bfcode{transport}}{\emph{temperature={[}300{]}, epsilon=True, run\_bands=True}}{}
Wrapper method to call AFLOWpi.scfuj.prep\_transport and AFLOWpi.scfuj.run\_transport
in the high level user interface. Adds a new step to the workflow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the \_calcs\_container object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{epsilon} (\emph{bool}) --
if True episilon tensor will be computed

\item {} 
\textbf{temperature} (\emph{list}) --
list of temperature(s) at which to calculate transport properties

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.values}\pysiglinewithargsret{\bfcode{values}}{}{}
\end{fulllineitems}

\index{vcrelax() (prep.calcs\_container method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.calcs_container.vcrelax}\pysiglinewithargsret{\bfcode{vcrelax}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{changeCalcs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.changeCalcs}\pysiglinewithargsret{\code{prep.}\bfcode{changeCalcs}}{\emph{calcs}, \emph{keyword='calculation'}, \emph{value='scf'}}{}
A Wrapper function that writes the function AFLOWpi.prep.\_\_changeCalcs to the \_\_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{keyword} (\emph{str}) --
a string which signifies the type of change that is to be made

\item {} 
\textbf{value} --
the value of the choice.

\end{itemize}

\item[{Returns}] \leavevmode
The identical set of calculations as the input to this function

\end{description}\end{quote}

\end{fulllineitems}

\index{cleanCalcs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.cleanCalcs}\pysiglinewithargsret{\code{prep.}\bfcode{cleanCalcs}}{\emph{calcs}, \emph{runlocal=False}}{}
Wrapper function for AFLOWpi.prep.\_\_cleanCalcs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_and\_run() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.construct_and_run}\pysiglinewithargsret{\code{prep.}\bfcode{construct\_and\_run}}{\emph{\_\_submitNodeName\_\_}, \emph{oneCalc}, \emph{ID}, \emph{build\_command='`}, \emph{subset\_tasks={[}{]}}, \emph{fault\_tolerant=False}, \emph{mult\_jobs=True}, \emph{subset\_name='SUBSET'}, \emph{keep\_file\_names=False}, \emph{clean\_input=True}}{}
this is a check to see if we're restarting when mult\_jobs==True

\end{fulllineitems}

\index{doss() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.doss}\pysiglinewithargsret{\code{prep.}\bfcode{doss}}{\emph{calcs}, \emph{kpFactor=1.5}}{}
Wrapper function to write the functio n AFLOWpi.prep.\_\_oneDoss to the \_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{kpFactor} (\emph{float}) --
the factor to which we make each direction in the kpoint grid denser

\item[{Returns}] \leavevmode
The identical ``calcs'' input variable

\end{description}\end{quote}

\end{fulllineitems}

\index{extractvars() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.extractvars}\pysiglinewithargsret{\code{prep.}\bfcode{extractvars}}{\emph{refFile}}{}
Read refFile and return an empty dictionary with all the keys and None values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{refFile}} (\emph{str}) -- filename of the reference input file for the frame

\item[{Returns}] \leavevmode
A dictionary containing the keyword extracted from the reference input file
as keys with None for values..

\end{description}\end{quote}

\end{fulllineitems}

\index{generateAnotherCalc() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.generateAnotherCalc}\pysiglinewithargsret{\code{prep.}\bfcode{generateAnotherCalc}}{\emph{old}, \emph{new}, \emph{calcs}}{}
Modify the calculation in each subdir and update the master dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{old}} (\emph{str}) -- string to replace

\item {} 
\textbf{\texttt{new}} (\emph{str}) -- replacement string

\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\end{itemize}

\item[{Returns}] \leavevmode
A new set of calculations with a new ID of the hash of the new input strings

\end{description}\end{quote}

\end{fulllineitems}

\index{getMPGrid() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.getMPGrid}\pysiglinewithargsret{\code{prep.}\bfcode{getMPGrid}}{\emph{primLatVec}, \emph{offset=True}, \emph{string=True}}{}
\end{fulllineitems}

\index{init (class in prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init}\pysiglinewithargsret{\strong{class }\code{prep.}\bfcode{init}}{\emph{PROJECT}, \emph{SET='`}, \emph{AUTHOR='`}, \emph{CORRESPONDING='`}, \emph{SPONSOR='`}, \emph{config='`}, \emph{workdir=None}}{}~\index{from\_file() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.from_file}\pysiglinewithargsret{\bfcode{from\_file}}{\emph{fileList}, \emph{reffile=None}, \emph{pseudodir=None}, \emph{build=True}, \emph{workdir=None}}{}
Reads in a string of an QE input file path, a string of an QE input, a file object of a
QE input or a list of them and attempts to fill create a calculation from them. If they
are missing things such as k\_points card, they are automtically generated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{aflowkeys}} (\emph{dict}) -- a dictionary generated by AFLOWpi.prep.init

\item {} 
\textbf{\texttt{fileList}} (\emph{str}) -- a string of an QE input file path, a string of an QE input, a file
object of a QE input or a list of them

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{reffile} (\emph{str}) --
a partially filled QE input file used in case the input(s) in fileList
are missing. i.e. wfc cutoff. If the names of the Pseudopotential files
are not included in the input(s) in fileList, they are chosen depending
on the pseudodir chosen and included when the calculation set is formed.

\item {} 
\textbf{workdir} (\emph{str}) --
a string of the workdir path that be used to override what is in the
config file used when initating the AFLOWpi session

\item {} 
\textbf{pseudodir} (\emph{str}) --
a string of the pseudodir path that be used to override what is in
the config file used when initating the AFLOWpi session

\item {} 
\textbf{build} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{items() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.items}\pysiglinewithargsret{\bfcode{items}}{}{}
\end{fulllineitems}

\index{iteritems() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.iteritems}\pysiglinewithargsret{\bfcode{iteritems}}{}{}
\end{fulllineitems}

\index{keys() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
\end{fulllineitems}

\index{load() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.load}\pysiglinewithargsret{\bfcode{load}}{\emph{step=1}}{}
Loads the calc logs from a given step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{step}} (\emph{int}) -- the step of the calculation for whose calclogs are to be loaded

\item[{Returns}] \leavevmode
\textbf{calcs} --
the loaded calc logs

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{scfs() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.scfs}\pysiglinewithargsret{\bfcode{scfs}}{\emph{allAFLOWpiVars}, \emph{refFile}, \emph{name='first'}, \emph{pseudodir=None}, \emph{build\_type='product'}, \emph{build=True}, \emph{run=True}}{}
A wrapper method to call AFLOWpi.prep.scfs to form the calculation set. This will
also create directory within the set directory for every calculation in the set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{allAFLOWpiVars}} (\emph{dict}) -- a dictionary whose keys correspond to the keywords in the
reference input file and whose values will be used to
construct the set of calculations

\item {} 
\textbf{\texttt{refFile}} (\emph{str}) -- a filename as a string, a file object, or a string of the file
that contains keywords to construct the inputs to the different
calculations in the set

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{pseudodir} (\emph{str}) --
path of the directory that contains your Pseudopotential files
The value in the AFLOWpi config file used will override this.

\item {} 
\textbf{build\_type} (\emph{str}) --
how to construct the calculation set from allAFLOWpiVars dictionary:
\begin{description}
\item[{zip \textbar{} The first calculation takes the first entry from the list of}] \leavevmode
\begin{DUlineblock}{0em}
\item[] each of the keywords. The second calculation takes the second
\item[] and so on. The keywords for all lists in allAFLOWpiVars must be
\item[] the same length for this method.
\end{DUlineblock}

\item[{product \textbar{} Calculation set is formed via a ``cartesian product'' with}] \leavevmode
\begin{DUlineblock}{0em}
\item[] the values the list of each keyword combined. (i.e if
\item[] allAFLOWpiVars has one keyword with a list of 5 entires and
\item[] another with 4 and a third with 10, there would be 2000
\item[] calculations in the set formed from them via product mode.
\end{DUlineblock}

\end{description}

\item {} 
\textbf{build} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\item {} 
\textbf{run} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary of dictionaries containing the set of calculations.

\end{description}\end{quote}

\end{fulllineitems}

\index{status() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.status}\pysiglinewithargsret{\bfcode{status}}{\emph{status=\{\}}, \emph{step=0}, \emph{negate\_status=False}}{}
Loads the calc logs from a given step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{step}} (\emph{int}) -- The step of the calculation for whose calclogs are to be loaded.
If no step is specified then it will default to load calculations
from all steps with the chosen status.

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{status} (\emph{dict}) --
key,value pairs for status type and their value to filter on.
i.e. status=\{`Finished':False\}

\item {} 
\textbf{negate\_status} (\emph{bool}) --
filter on the opposite of the status filters

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{calcs} --
the loaded calcs for one or more steps with the given status

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (prep.init method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init.values}\pysiglinewithargsret{\bfcode{values}}{}{}
\end{fulllineitems}


\end{fulllineitems}

\index{init\_\_() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.init__}\pysiglinewithargsret{\code{prep.}\bfcode{init\_\_}}{\emph{PROJECT}, \emph{SET='`}, \emph{AUTHOR='`}, \emph{CORRESPONDING='`}, \emph{SPONSOR='`}, \emph{config='`}, \emph{workdir=None}}{}
Initializes the frame
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{PROJECT}} (\emph{str}) -- Name of project

\item {} 
\textbf{\texttt{SET}} (\emph{str}) -- Name of set

\item {} 
\textbf{\texttt{author}} (\emph{str}) -- Name of author

\item {} 
\textbf{\texttt{CORRESPONDING}} (\emph{str}) -- Name of corresponding

\item {} 
\textbf{\texttt{SPONSOR}} (\emph{str}) -- Name of sponsor

\end{itemize}

\end{description}\end{quote}

e.g. initFrame(`LNTYPE','`, `MF', \href{mailto:'marco.fornari@cmich.edu}{`marco.fornari@cmich.edu}`,'DOD-MURI'). Return the AFLOKEYS dictionary.

\end{fulllineitems}

\index{line\_prepender() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.line_prepender}\pysiglinewithargsret{\code{prep.}\bfcode{line\_prepender}}{\emph{filename}, \emph{new\_text}}{}
prepends a file with a new line containing the contents of the string new\_text.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} (\emph{str}) -- string of the filename that is to be prepended

\item {} 
\textbf{\texttt{new\_text}} (\emph{str}) -- a string that is one line long to be prepended to the file

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{loadlogs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.loadlogs}\pysiglinewithargsret{\code{prep.}\bfcode{loadlogs}}{\emph{PROJECT='`}, \emph{SET='`}, \emph{logname='`}, \emph{config=None}}{}
\end{fulllineitems}

\index{lockAtomMovement() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.lockAtomMovement}\pysiglinewithargsret{\code{prep.}\bfcode{lockAtomMovement}}{\emph{calcs}}{}
A Wrapper function that writes the function AFLOWpi.prep.\_\_freezeAtoms to the \_\_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{maketree() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.maketree}\pysiglinewithargsret{\code{prep.}\bfcode{maketree}}{\emph{calcs}, \emph{pseudodir=None}, \emph{build=True}, \emph{workdir=None}}{}
Make the directoy tree and place in the input file there
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- \begin{itemize}
\item {} 
Dictionary of dictionaries of calculations

\end{itemize}


\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{pseudodir} (\emph{str}) --
path of pseudopotential files directory

\item {} 
\textbf{workdir} (\emph{str}) --
a string of the workdir path that be used to override what is in the
config file used when initating the AFLOWpi session

\item {} 
\textbf{build} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{modifyCalcs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.modifyCalcs}\pysiglinewithargsret{\code{prep.}\bfcode{modifyCalcs}}{\emph{old}, \emph{new}, \emph{calcs}}{}
Modify the calculation in each subdir and update the master dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{old}} (\emph{str}) -- string to replace

\item {} 
\textbf{\texttt{new}} (\emph{str}) -- replacement string

\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{modifyInputPrefixPW() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.modifyInputPrefixPW}\pysiglinewithargsret{\code{prep.}\bfcode{modifyInputPrefixPW}}{\emph{calcs}, \emph{pre}}{}
A Wrapper function that is used to write a function to the \_\_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{modifyNamelistPW() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.modifyNamelistPW}\pysiglinewithargsret{\code{prep.}\bfcode{modifyNamelistPW}}{\emph{calcs}, \emph{namelist}, \emph{parameter}, \emph{value}, \emph{runlocal=False}}{}
A Wrapper function that is used to write the function AFLOWpi.prep.\_\_modifyNameListPW
to the \_ID.py. If the value is intended to be a string in the QE input file, it must
be dually quoted i.e. value=```scf''' will become `scf' in the input file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item {} 
\textbf{\texttt{namelist}} (\emph{str}) -- a string of the fortran namelist that the parameter is in

\item {} 
\textbf{\texttt{parameter}} (\emph{str}) -- a string of the parameter name

\item {} 
\textbf{\texttt{value}} -- the value of that parameter

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow.

\item[{Returns}] \leavevmode
Either the identical set of calculations if runlocal == False or the set of
calculations with the parameter's value changed in their oneCalc{[}'\_AFLOWPI\_INPUT\_'{]}
if runlocal==True

\end{description}\end{quote}

\end{fulllineitems}

\index{newstepWrapper() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.newstepWrapper}\pysiglinewithargsret{\code{prep.}\bfcode{newstepWrapper}}{\emph{pre}}{}
A function that wraps another function that is to be run before the
a certain function runs. Its use must be in the form:

@newstepwrapper(func)
def being\_wrapped(oneCalc,ID,*args,**kwargs)

where func is the function that is to be run before and being\_wrapped
is the function being wrapped. oneCalc and ID must be the first two
arguments in the function being wrapped. additional arguments and
keyword arguments can follow.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{pre}} (\emph{func}) -- function object that is to be wrapped before another function runs

\item[{Returns}] \leavevmode
the returned values of function being wrapped or the execution of the function
is skipped entirely.

\end{description}\end{quote}

\end{fulllineitems}

\index{plotter (class in prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter}\pysiglinewithargsret{\strong{class }\code{prep.}\bfcode{plotter}}{\emph{calcs}}{}
Class for adding common plotting functions from AFLOWpi.plot module to the high level user
interface.
\index{bands() (prep.plotter method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter.bands}\pysiglinewithargsret{\bfcode{bands}}{\emph{yLim={[}-10, 10{]}, DOSPlot='`, LSDA=False, runlocal=False, postfix='`}}{}
Wrapper method to call AFLOWpi.plot.bands in the high level user interface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the plotter object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
a tuple or list of the range of energy around the fermi/Highest
occupied level energy that is to be included in the plot.

\item {} 
\textbf{DOSPlot} (\emph{str}) --
a string that flags for the option to have either a DOS plot
share the Y-axis of the band structure plot.

Options include:
``''      \textbar{} A blank string (default) will cause No Density of
\begin{quote}

\begin{DUlineblock}{0em}
\item[] States plotted alongside the Band Structure
\end{DUlineblock}
\end{quote}

``APDOS'' \textbar{} Atom Projected Density of States
``DOS''   \textbar{} Normal Density of States

\item {} 
\textbf{LSDA} (\emph{bool}) --
Plot the up and down of a spin polarized orbital projected DOS
calculation.

\item {} 
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow

\item {} 
\textbf{postfix} (\emph{str}) --
a string of an optional postfix to the plot filename for every
calculation.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{dos() (prep.plotter method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter.dos}\pysiglinewithargsret{\bfcode{dos}}{\emph{yLim={[}-10, 10{]}, LSDA=False, runlocal=False, postfix='`}}{}
Wrapper method to call AFLOWpi.plot.dos in the high level user interface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the plotter object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
a tuple or list of the range of energy around the fermi/Highest
occupied level energy that is to be included in the plot.

\item {} 
\textbf{LSDA} (\emph{bool}) --
Plot the up and down of a spin polarized DOS
calculation.

\item {} 
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow

\item {} 
\textbf{postfix} (\emph{str}) --
a string of an optional postfix to the plot filename for every
calculation.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{opdos() (prep.plotter method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter.opdos}\pysiglinewithargsret{\bfcode{opdos}}{\emph{yLim={[}-10, 10{]}, LSDA=False, runlocal=False, postfix='`}}{}
Wrapper method to call AFLOWpi.plot.opdos in the high level user interface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the plotter object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{yLim} (\emph{list}) --
a tuple or list of the range of energy around the fermi/Highest
occupied level energy that is to be included in the plot.

\item {} 
\textbf{LSDA} (\emph{bool}) --
Plot the up and down of a spin polarized orbital projected DOS
calculation.

\item {} 
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow

\item {} 
\textbf{postfix} (\emph{string}) --
a string of an optional postfix to the plot filename for every
calculation.

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{phonon() (prep.plotter method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter.phonon}\pysiglinewithargsret{\bfcode{phonon}}{\emph{runlocal=False}, \emph{postfix='`}, \emph{THz=True}}{}
\end{fulllineitems}

\index{transport() (prep.plotter method)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.plotter.transport}\pysiglinewithargsret{\bfcode{transport}}{\emph{runlocal=False}, \emph{postfix='`}}{}
Wrapper method to call AFLOWpi.plot.epsilon in the high level user interface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{self}} -- the plotter object

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{nm} (\emph{bool}) --
whether to plot in nanometers for spectrum or eV for energy

\item {} 
\textbf{runlocal} (\emph{bool}) --
a flag to choose whether or not to run the wrapped function now
or write it to the \_ID.py to run during the workflow

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{prep\_split\_step() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.prep_split_step}\pysiglinewithargsret{\code{prep.}\bfcode{prep\_split\_step}}{\emph{calcs}, \emph{subset\_creator}, \emph{subset\_tasks={[}{]}}, \emph{mult\_jobs=False}, \emph{substep\_name='SUBSET'}, \emph{keep\_file\_names=False}, \emph{clean\_input=True}}{}
\end{fulllineitems}

\index{remove\_blank\_lines() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.remove_blank_lines}\pysiglinewithargsret{\code{prep.}\bfcode{remove\_blank\_lines}}{\emph{inp\_str}}{}
Removes whitespace lines of text
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inp\_str}} (\emph{str}) -- input string of text

\item[{Returns}] \leavevmode
the same string with blank lines removed

\end{description}\end{quote}

\end{fulllineitems}

\index{runAfterAllDone() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.runAfterAllDone}\pysiglinewithargsret{\code{prep.}\bfcode{runAfterAllDone}}{\emph{calcs}, \emph{command}, \emph{faultTolerant=True}}{}
Adds a command to the BATCH command block at the end of each calculation's \_ID.py
for all calculations in the set. Used to execute a command over all calculations
in particular step have completed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{command} (\emph{str}) --
the text to be added to the BATCH block

\item {} 
\textbf{faultTolerant} (\emph{bool}) --
a flag to choose if we return True if some of the
calculations ran but did not complete successful

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{scfs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.scfs}\pysiglinewithargsret{\code{prep.}\bfcode{scfs}}{\emph{aflowkeys}, \emph{allAFLOWpiVars}, \emph{refFile}, \emph{pseudodir=None}, \emph{build\_type='product'}, \emph{build=True}}{}
Read a reference input file, and construct a set of calculations from the allAFLOWpiVars
dictionary defining values for the keywords in the reference input file. This will
also create directory within the set directory for every calculation in the set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{allAFLOWpiVars}} (\emph{dict}) -- a dictionary whose keys correspond to the keywords in the
reference input file and whose values will be used to
construct the set of calculations

\item {} 
\textbf{\texttt{refFile}} (\emph{str}) -- a filename as a string, a file object, or a string of the file
that contains keywords to construct the inputs to the different
calculations in the set

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{pseudodir} (\emph{str}) --
path of the directory that contains your Pseudopotential files
The value in the AFLOWpi config file used will override this.

\item {} 
\textbf{build\_type} (\emph{str}) --
how to construct the calculation set from allAFLOWpiVars dictionary:
\begin{description}
\item[{zip \textbar{} The first calculation takes the first entry from the list of}] \leavevmode
\begin{DUlineblock}{0em}
\item[] each of the keywords. The second calculation takes the second
\item[] and so on. The keywords for all lists in allAFLOWpiVars must be
\item[] the same length for this method.
\end{DUlineblock}

\item[{product \textbar{} Calculation set is formed via a ``cartesian product'' with}] \leavevmode
\begin{DUlineblock}{0em}
\item[] the values the list of each keyword combined. (i.e if
\item[] allAFLOWpiVars has one keyword with a list of 5 entires and
\item[] another with 4 and a third with 10, there would be 2000
\item[] calculations in the set formed from them via product mode.
\end{DUlineblock}

\end{description}

\item {} 
\textbf{build} (\emph{bool}) --
\textless{}DEFUNCT OPTION. NEEDS REMOVAL\textgreater{}

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary of dictionaries containing the set of calculations.

\end{description}\end{quote}

\end{fulllineitems}

\index{totree() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.totree}\pysiglinewithargsret{\code{prep.}\bfcode{totree}}{\emph{tobecopied}, \emph{calcs}, \emph{rename=None}, \emph{symlink=False}}{}
Populate all the subdirectories for the calculation with the file in input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{tobecopied}} (\emph{str}) -- filepath to be copied to the AFLOWpi directory tree

\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{rename} (\emph{bool}) --
option to rename the file/directory being moves into the AFLOWpi
directory tree

\item {} 
\textbf{symlink} (\emph{bool}) --
whether to copy the data to the AFLOWpi directory tree or
to use symbolic links

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{unlockAtomMovement() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.unlockAtomMovement}\pysiglinewithargsret{\code{prep.}\bfcode{unlockAtomMovement}}{\emph{calcs}}{}
A Wrapper function that writes the function AFLOWpi.prep.\_\_unfreezeAtoms to the \_\_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{updateStructs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.updateStructs}\pysiglinewithargsret{\code{prep.}\bfcode{updateStructs}}{\emph{calcs}, \emph{update\_structure=True}, \emph{update\_positions=True}}{}
A Wrapper function that writes the function AFLOWpi.prep.\_\_oneUpdateStructs to the \_\_ID.py
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- a dictionary of dicionaries representing the set of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{update\_structure} (\emph{bool}) --
if True update the cell parameter if possible from the
output of previous calculations in the workflow.

\item {} 
\textbf{update\_positions} (\emph{bool}) --
if True update the atomic positions if possible from the
output of previous calculations in the workflow.

\end{itemize}

\item[{Returns}] \leavevmode
The identical set of calculations as the input to this function

\end{description}\end{quote}

\end{fulllineitems}

\index{updatelogs() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.updatelogs}\pysiglinewithargsret{\code{prep.}\bfcode{updatelogs}}{\emph{calcs}, \emph{logname}, \emph{runlocal=False}}{}
\end{fulllineitems}

\index{varyCellParams() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.varyCellParams}\pysiglinewithargsret{\code{prep.}\bfcode{varyCellParams}}{\emph{oneCalc}, \emph{ID}, \emph{param=()}, \emph{amount=0.15}, \emph{steps=8}, \emph{constraint=None}}{}
Forms and returns a set of calcs with varied cell params must be in A,B,C,
and, in degrees,alpha,beta,gamma and then returns it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{param} (\emph{tuple}) --
the params assoc. with the amount and step. i.e. (`celldm(1)','celldm(3))

\item {} 
\textbf{amount} (\emph{float}) --
percentage amount to be varied up and down. i.e (0.04,0.02,0.01)

\item {} 
\textbf{steps} (\emph{int}) --
how many steps to within each range. i.e (4,5,7)

\item {} 
\textbf{constraint} (\emph{list}) --
a list or tuple containing two entry long list or tuples with
the first being the constraint type and the second the free
parameter in params that its constraining for example in a
orthorhombic cell: constraint=({[}''volume'','c'{]},) allows for A and B
to move freely but C is such that it keeps the cell volume the same
in all calculations generated by the input oneCalc calculation.

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary of dictionaries representing a new calculation set

\end{description}\end{quote}

\end{fulllineitems}

\index{writeToScript() (in module prep)}

\begin{fulllineitems}
\phantomsection\label{prep:prep.writeToScript}\pysiglinewithargsret{\code{prep.}\bfcode{writeToScript}}{\emph{executable}, \emph{calcs}, \emph{from\_step=0}}{}
Generates calls on several functions to set up everything that is needed for a new step in the workflow.
The mechanics of the \_ID.py are written to it here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item {} 
\textbf{\texttt{executable}} (\emph{str}) -- \textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\item {} 
\textbf{\texttt{*args}} -- \textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{**kwargs} --
\textless{}DEFUNCT OPTION: HERE FOR LEGACY SUPPORT\textgreater{}

\item[{Returns}] \leavevmode
A set of calculations for a new step in the workflow

\end{description}\end{quote}

\end{fulllineitems}



\chapter{pseudo module}
\label{pseudo::doc}\label{pseudo:pseudo-module}\label{pseudo:module-pseudo}\index{pseudo (module)}\index{\_\_crawlingMinimization() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__crawlingMinimization}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_crawlingMinimization}}{\emph{oneCalc}, \emph{ID}, \emph{fitVars=None}, \emph{options=None}, \emph{faultTolerant=True}, \emph{initial\_variance=0.15}, \emph{steps=10}, \emph{constraint=None}, \emph{thresh=0.001}, \emph{mult\_jobs=True}}{}
this is a check to see if we're restarting when mult\_jobs==True

\end{fulllineitems}

\index{\_\_cubicInterpolation() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__cubicInterpolation}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_cubicInterpolation}}{\emph{variable\_array}, \emph{solution\_array}}{}
try to convert a numpy array into a list if
this fails assume that the inputs are lists

\end{fulllineitems}

\index{\_\_cubicInterpolation\_onePoint() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__cubicInterpolation_onePoint}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_cubicInterpolation\_onePoint}}{\emph{point}, \emph{variable\_array}, \emph{solution\_array}}{}
try to convert a numpy array into a list if
this fails assume that the inputs are lists

\end{fulllineitems}

\index{\_\_getCutOffs() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__getCutOffs}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_getCutOffs}}{\emph{calcs}}{}
Looks through a random `sample' calculations in the dictionary of dictionaries of calculations
to see which cutoff variables are defined in the set of calculations and returns a list of
those cutoffs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs -{-} Dictionary of dictionaries of calculations}} (\emph{-}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getMin() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__getMin}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_getMin}}{\emph{calcs}, \emph{fitVars=None}, \emph{options=None}, \emph{bulk\_modulus=False}, \emph{minimize\_var='Energy'}}{}
calculates the minimum energy value from the fit variables you supply.
Only picks out the energy values that satisfy the cutoff/kpoint values
for one combination of them that you are testing
(i.e. would calculate the minimum energy from calculations that satisfy
\{\_AFLOWPI\_KPOINTS\_ = `4 4 4 1 1 1', \_AFLOWPI\_ECUTW\_ = 20\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of Dictionaries of the calculations.

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{fitVars} (\emph{list}) --
a tuple of the independent variables you want to make the
fit and find the min energy for

\item {} 
\textbf{options} (\emph{dict}) --
additional options passed to L-BFGS-B minimization
(see scipy documentation for scipy.optimize.minimize
for more details)

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{minEnergy} --
the minimum energy of the fit
outDict (dict): dictionary containing fit information

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getMinimization() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__getMinimization}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_getMinimization}}{\emph{origCalcs}, \emph{fitVars=None}, \emph{options=None}, \emph{return\_energy=False}, \emph{minimize\_var='Energy'}}{}
Looks through the dictionary of dictionaries that you supply it and finds the minimum energy
for the different cutoff/kpoint choices. outputs a list of dictionaries with the information
about the cutoffs and the value of the variables that gives you a minimum energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{origCalcs}} (\emph{list}) -- a list of Dictionary of Dictionaries of the calculations.

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{fitVars} (\emph{list}) --
tuple of variables that you want to minimize energy with respect to.

\item {} 
\textbf{options} (\emph{dict}) --
additional options passed to L-BFGS-B minimization
(see scipy documentation for scipy.optimize.minimize for more details)

\item {} 
\textbf{return\_energy} (\emph{bool}) --
If true add the min energy to the resultList list for each

\item {} 
\textbf{minimize\_var} (\emph{str}) --
which key to minimize on in oneCalc

\end{itemize}

\item[{Returns}] \leavevmode

\textbf{resultList} --
list if minumum energies and the parameters of the set that they
\begin{quote}

correspond to.
\end{quote}


\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_grabEnergyOut() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__grabEnergyOut}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_grabEnergyOut}}{\emph{calcs}}{}
\textless{}CONSIDER MOVING TO retr.py\textgreater{}
Goes in every subdirectory of the calculation and searches for the final energy of the calculation
and returns a new copy of the input dictionary that includes the final energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of Dictionaries of the calculations.

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\end{description}\end{quote}

MASTER\_ENERGY (dict): Dictionary for the calc set with the energy added to each calc in the set

\end{fulllineitems}

\index{\_\_plotOne() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__plotOne}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_plotOne}}{\emph{plots}, \emph{labs}, \emph{fig}, \emph{entry}, \emph{key}, \emph{xaxis}, \emph{pltTitle=None}, \emph{rename=None}, \emph{entryNum=0}, \emph{maxs=None}, \emph{mins=None}}{}~\begin{quote}

takes in a list of dictionaries of dictionaries of calculations and generates
a plot with the x axis being some value in the list `key' and splits the calculations
and plots them with each plot being a unique combination of the items in key that are not
\end{quote}
\begin{description}
\item[{`xaxis'}] \leavevmode\begin{description}
\item[{Arguments:}] \leavevmode
entry (list): list of dictionaries of dictionaries of calculations
key (list): a list of cutoff variables used in the calculations
xaxis (str): the cutoff that you choose to be the x axis in your plots

\item[{Keyword Arguments:}] \leavevmode
plotTitle -- title of the plots (default: None)

\end{description}

\end{description}

\end{fulllineitems}

\index{\_\_shiftGrid() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__shiftGrid}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_shiftGrid}}{\emph{calcs}, \emph{outFile}, \emph{fitVars=None}, \emph{options=None}, \emph{constraint=None}, \emph{thresh=0.001}, \emph{mult\_jobs=True}}{}
sleep for anywhere from 0 to 10 seconds

\end{fulllineitems}

\index{\_\_splitCalcs() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.__splitCalcs}\pysiglinewithargsret{\code{pseudo.}\bfcode{\_\_splitCalcs}}{\emph{calcs}, \emph{splitVars='`}}{}
splits a set of calculations by keyword and its respective values and
returns the split set of calculations as a list of the split set.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionary of calculations that is to be split

\item[{Keyword Arguments}] \leavevmode
\textbf{splitVars} (\emph{list}) --
a list or tuple of strings of AFLOWpi variable(s) in the
set of calculations that you want to split the set on

\item[{Returns}] \leavevmode
\textbf{splitCalcList} --
a list of dictionaries of dictionaries

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{brute\_test() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.brute_test}\pysiglinewithargsret{\code{pseudo.}\bfcode{brute\_test}}{\emph{calcs}, \emph{ecutwfc}, \emph{dual=None}, \emph{sampling=None}, \emph{constraint=None}, \emph{thresh=0.001}, \emph{initial\_variance=0.05}, \emph{grid\_density=10}, \emph{mult\_jobs=False}, \emph{conv\_thresh=0.01}, \emph{calc\_type='relax'}}{}
\end{fulllineitems}

\index{crawlingMinimization() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.crawlingMinimization}\pysiglinewithargsret{\code{pseudo.}\bfcode{crawlingMinimization}}{\emph{calcs}, \emph{options=None}, \emph{faultTolerant=True}, \emph{constraint=None}, \emph{thresh=0.001}, \emph{initial\_variance=0.05}, \emph{grid\_density=10}, \emph{mult\_jobs=False}, \emph{final\_minimization='relax'}}{}
\end{fulllineitems}

\index{getMinimization() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.getMinimization}\pysiglinewithargsret{\code{pseudo.}\bfcode{getMinimization}}{\emph{origCalcs}, \emph{fitVars=None}, \emph{options=None}, \emph{runlocal=False}, \emph{faultTolerant=True}, \emph{minimize\_var='Energy'}}{}
\end{fulllineitems}

\index{plot() (in module pseudo)}

\begin{fulllineitems}
\phantomsection\label{pseudo:pseudo.plot}\pysiglinewithargsret{\code{pseudo.}\bfcode{plot}}{\emph{resultList}, \emph{xaxis='`}, \emph{xtitle=None}, \emph{ytitle=None}, \emph{title=None}, \emph{rename=None}, \emph{file\_name='`}}{}
takes in a list of dictionaries of dictionaries of calculations and generates
a plot with the x axis being some value in the list `key' and splits the calculations
and plots them with each plot being a unique combination of the items in key that are not
`xaxis'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{resultList}} (\emph{list}) -- list of dictionaries of dictionaries of calculations

\item {} 
\textbf{\texttt{xaxis}} (\emph{str}) -- the keyword in oneCalc that you choose to be the x axis in your plots

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{xtitle} (\emph{str}) --
title of the x axis of the plot (default: None)

\item {} 
\textbf{ytitle} (\emph{str}) --
title of the y axis of the plot (default: None)

\item {} 
\textbf{plotTitle} (\emph{str}) --
title of the plots (default: None)

\item {} 
\textbf{rename} (\emph{dict}) --
a mapping of the names of the keywords of whose
values used to generate the plot to some other name.
ex. \{` \_AFLOWPI\_ECUTW\_':'wavefunction cutoff'\}

\item {} 
\textbf{file\_name} (\emph{str}) --
use this instead of ``PT\_RESULTS.pdf'' as filename of plot

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\chapter{retr module}
\label{retr::doc}\label{retr:retr-module}\label{retr:module-retr}\index{retr (module)}\index{\_\_cellMatrixToString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__cellMatrixToString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_cellMatrixToString}}{\emph{cellMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_cellStringToMatrix() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__cellStringToMatrix}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_cellStringToMatrix}}{\emph{cellParamString}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_checkEqualPoint() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__checkEqualPoint}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_checkEqualPoint}}{\emph{oldMatrix}, \emph{newMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_conv2PrimVec() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__conv2PrimVec}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_conv2PrimVec}}{\emph{cellParamMatrix}, \emph{ibrav=0}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_conv2primPositions() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__conv2primPositions}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_conv2primPositions}}{\emph{symMatrix}, \emph{cellParamMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_convertCartesian() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__convertCartesian}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_convertCartesian}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{scaleFactor=1}}{}
Converts atomic positions from crystal to cartesian coordinates
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{scaleFactor} (\emph{int}) --
scaling factor for output matrix

\item[{Returns}] \leavevmode
in\_cart (postions in cartiesian coordinates)

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_convertCellBC() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__convertCellBC}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_convertCellBC}}{\emph{cellVectors}, \emph{toPrimOrConv='conv'}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_convertFractional() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__convertFractional}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_convertFractional}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{scaleFactor=1}}{}
Converts atomic positions from cartesian to crystal coordinates
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{scaleFactor} (\emph{int}) --
scaling factor for output matrix

\item[{Returns}] \leavevmode
\textbf{in\_cart} --
postions in crystal coordinates

\item[{Return type}] \leavevmode
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_duplicateEdgeAtoms() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__duplicateEdgeAtoms}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_duplicateEdgeAtoms}}{\emph{symMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_expandBoundariesNoScale() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__expandBoundariesNoScale}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_expandBoundariesNoScale}}{\emph{labels}, \emph{symMatrix}, \emph{numX}, \emph{numY}, \emph{numZ}, \emph{inList=False}, \emph{expand=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_find\_numkpoints() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__find_numkpoints}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_find\_numkpoints}}{\emph{outputFile}}{}
DEFUNCT \textless{}TAGGED FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_free2celldm() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__free2celldm}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_free2celldm}}{\emph{cellparamatrix}, \emph{ibrav=0}, \emph{primitive=True}}{}
Convert lattice vectors to celldm
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cellparamatrix}} (\emph{numpy.matrix}) -- matrix of cell vectors

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{ibrav} (\emph{int}) --
Overrides the bravais lattice automatically detected
(must be in QE convention if primitive)

\item {} 
\textbf{primitive} (\emph{bool}) --
If True it will treat cellparamatrix as primitive lattice vectors

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{paramDict} --
dictionary of the celldm generated by the input matrix

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getAlatFromInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getAlatFromInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getAlatFromInput}}{\emph{inputString}}{}
Grabs the value of alat from the QE pwscf input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} -- 

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{alat} --
the alat scale for the primitive lattice vectors

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getAtomNum() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getAtomNum}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getAtomNum}}{\emph{inputString}, \emph{strip=False}}{}
Gets the number of atoms from a QE pwscf input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputString}} (\emph{str}) -- String of a QE pwscf input file

\item[{Keyword Arguments}] \leavevmode
\textbf{strip} (\emph{bool}) --
If True then Cr2,Cr45,Cr would be all considered the same species

\item[{Returns}] \leavevmode
\textbf{numOfEach} --
dictionary with keys for the species labels and values the number

\item[{Return type}] \leavevmode
collections.OrderedDict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getCartConvMatrix() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getCartConvMatrix}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getCartConvMatrix}}{\emph{symMatrix}, \emph{cellMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_getCellInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getCellInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getCellInput}}{\emph{oneCalc}, \emph{ID}, \emph{scaled=True}}{}
Gets the primitive cell vectors from the input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{scaled} (\emph{bool}) --
scale vectors by alat

\item[{Returns}] \leavevmode
\textbf{symMatrix} --
matrix representing primive lattice vectors

\item[{Return type}] \leavevmode
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getCellOutDim() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getCellOutDim}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getCellOutDim}}{\emph{oneCalc}, \emph{ID}}{}
Returns the cell parameters a,b,c,alpha,beta,gamma of the primitive lattice from the output.
If the primitive lattice does not change during the calculation it takes it from the input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{out\_params} --
dictionary of a,b,c,alpha,beta,gamma of the primitive lattice from the output

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getCellParams() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getCellParams}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getCellParams}}{\emph{oneCalc}, \emph{ID}}{}
Reads the output from the SCF or relax calculation to get the primitive cell parameters
produced by the calculation. If it fails it defaults to the input lattice vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary of a single calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{alat} --
the scale for the lattice vectors
cell\_matrix (numpy.array): the unscaled primitive lattice vectors

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getCelldm2freeDict() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getCelldm2freeDict}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getCelldm2freeDict}}{\emph{free2celldm\_output\_dict}}{}
Cleans fortran array format into a format for python ex. celldm(1) to celldm1
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{free2celldm\_output\_dict}} (\emph{dict}) -- output from AFLOWpi.retr.free2celldm

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
output\_dict (dict) dictionary with cleaned keywords

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getConventionalCellFromInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getConventionalCellFromInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getConventionalCellFromInput}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_getConventionalCellFromOutput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getConventionalCellFromOutput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getConventionalCellFromOutput}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_getEfermi() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getEfermi}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getEfermi}}{\emph{oneCalc}, \emph{ID}}{}
Grabs fermi level from \textless{}ID\textgreater{}.efermi file. if there is none returns 0.0
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{efermi} --
fermi level

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getHighSymPoints() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getHighSymPoints}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getHighSymPoints}}{\emph{oneCalc}, \emph{ID=None}}{}
Searching for the ibrav number in the input file for the calculation
to determine the path for the band structure calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item[{Keyword Arguments}] \leavevmode
\textbf{ID} (\emph{str}) --
ID string for the particular calculation and step

\item[{Returns}] \leavevmode
\textbf{special\_points} --
list of the HSP names
band\_path (str): path in string form

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getInitialInputString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getInitialInputString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getInitialInputString}}{\emph{oneCalc}}{}
Gets initial input to the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{inFileString} --
initial input to the workflow

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getInitialOutputString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getInitialOutputString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getInitialOutputString}}{\emph{oneCalc}}{}
Gets initial output to the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{inFileString} --
initial output to the workflow

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getInputFileString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getInputFileString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getInputFileString}}{\emph{oneCalc}, \emph{ID}}{}
Gets the string of the input that step of the calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{inFileString} --
input string to that calculation step

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getInputParams() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getInputParams}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getInputParams}}{\emph{oneCalc}, \emph{ID}}{}
Returns the cell parameters a,b,c,alpha,beta,gamma of the primitive lattice from the input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{out\_params} --
dictionary of a,b,c,alpha,beta,gamma of the primitive lattice from the input

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getOutputString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getOutputString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getOutputString}}{\emph{oneCalc}, \emph{ID}}{}
Gets string of output for that particular step in the workflow for a single calcualtion
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{outFileString} --
output of that particular step in the workflow

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPath() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getPath}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getPath}}{\emph{dk}, \emph{oneCalc}, \emph{ID=None}, \emph{points=False}}{}
Get path between HSP
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dk}} (\emph{float}) -- distance between points

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{ID} (\emph{str}) --
ID string for the particular calculation and step

\item {} 
\textbf{points} (\emph{bool}) --
Give the path as points or in aflow convention

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{numPointStr} --
path between HSP

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPathFromFile() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getPathFromFile}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getPathFromFile}}{\emph{oneCalc}}{}
Reads the input file for the band structure calculation and retrieves the
k point path from the file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- one calculation that is a dictionary of values associated with that calculation

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{path} --
k point path for bands in the bands pwscf input file

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPosLabels() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getPosLabels}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getPosLabels}}{\emph{inputString}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_getPositions() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getPositions}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getPositions}}{\emph{inputString}, \emph{matrix=True}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_getStoicName() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getStoicName}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getStoicName}}{\emph{oneCalc}, \emph{strip=False}, \emph{latex=False}}{}
Determines the name of the compound by looking at the input and
finds the stoichiometric number of species in the compound
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- one calculation that is a dictionary of values associated with that calculation

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{strip} (\emph{bool}) --
strip species number when it equals 1

\item {} 
\textbf{latex} (\emph{bool}) --
output string in latex format

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{name} --
chemical namex

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getSymList() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getSymList}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getSymList}}{\emph{ID}, \emph{oneCalc}}{}
Gets symmetry operations from output if available
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{joinedList} --
a string of the sym ops pulled from the engine output

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getSymmInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__getSymmInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_getSymmInput}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_get\_pool\_num() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__get_pool_num}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_get\_pool\_num}}{\emph{oneCalc}, \emph{ID}}{}
Gets number of pools requested for this particular execution for engine.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{npool} --
number of pools requested for this particular execution for engine

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_invertX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__invertX}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_invertX}}{\emph{coordVec}, \emph{xScale=1}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_invertXYZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__invertXYZ}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_invertXYZ}}{\emph{coordVec}, \emph{xScale}, \emph{yScale}, \emph{zScale}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_invertY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__invertY}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_invertY}}{\emph{coordVec}, \emph{yScale=1}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_invertZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__invertZ}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_invertZ}}{\emph{coordVec}, \emph{zScale=1}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_joinInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__joinInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_joinInput}}{\emph{inputDict}}{}
Joins input tokenized by AFLOWpi.retr.\_\_splitInput and returns a string of a QE pwscf input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputDict}} (\emph{dict}) -- tokenized input file

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{newInputString} --
a string of a QE pwscf input file

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_joinMatrixLabels() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__joinMatrixLabels}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_joinMatrixLabels}}{\emph{labels}, \emph{matrix}}{}
Joins a list of the atomic position species labels with a list or array of their atomic positions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{labels}} (\emph{list}) -- list or array of the atomic positions species labels

\item {} 
\textbf{\texttt{matrix}} (\emph{numpy.matrix}) -- the positions in matrix, array, or list form

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{outString} --
a string of the atomic positions joined with their species labels

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_moveToSavedir() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__moveToSavedir}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_moveToSavedir}}{\emph{filePath}}{}
Move a file to the savedir specified in the config file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filePath}} (\emph{str}) -- path of the file to be copied

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_orderSplitInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__orderSplitInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_orderSplitInput}}{\emph{inputCalc}}{}
Order tokenized input as QE needs it
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inputCalc}} (\emph{calc}) -- tokenized QE pwscf input

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{newOrderedDict} --
the ordered tokenized QE pwscf input

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_prefixFromInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__prefixFromInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_prefixFromInput}}{\emph{inputString}}{}
DEFUNCT \textless{}CONSIDER FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_prim2ConvMatrix() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__prim2ConvMatrix}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_prim2ConvMatrix}}{\emph{cellParamMatrix}, \emph{ibrav=0}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_prim2ConvVec() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__prim2ConvVec}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_prim2ConvVec}}{\emph{cellParamMatrix}, \emph{ibrav=0}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_prim2convPositions() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__prim2convPositions}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_prim2convPositions}}{\emph{labels}, \emph{symMatrix}, \emph{cellParamMatrix}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_pw2aflowConvention() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__pw2aflowConvention}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_pw2aflowConvention}}{\emph{cellParamMatrix}, \emph{symMatrix}}{}
DEFUNCT \textless{}CONSIDER FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_pw2aflowConventionVec() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__pw2aflowConventionVec}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_pw2aflowConventionVec}}{\emph{cellParamMatrix}}{}
DEFUNCT \textless{}CONSIDER FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_pw2aflowPositions() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__pw2aflowPositions}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_pw2aflowPositions}}{\emph{cellParamMatrix}, \emph{symMatrix}}{}
DEFUNCT \textless{}CONSIDER FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_pw2cif() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__pw2cif}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_pw2cif}}{\emph{oneCalc}, \emph{ID}, \emph{inOrOut='input'}, \emph{outputFolder=None}, \emph{filePrefix='`}}{}
Generates the CIF from input or output of single calculation at that step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{inOrOut} (\emph{str}) --
which structs to do CIF for.. `input' `output' or `both'

\item {} 
\textbf{outputFolder} (\emph{str}) --
Output directory for the CIF

\item {} 
\textbf{filePrefix} (\emph{str}) --
Optional prefix to the CIF filenames

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_reduceDuplicates() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__reduceDuplicates}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_reduceDuplicates}}{\emph{symMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_rho2hex() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__rho2hex}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_rho2hex}}{\emph{cellParamMatrix}, \emph{symMatrix}, \emph{labels}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_rotateAlpha() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__rotateAlpha}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_rotateAlpha}}{\emph{coordVec}, \emph{angle}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_rotateBeta() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__rotateBeta}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_rotateBeta}}{\emph{coordVec}, \emph{angle}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_rotateGamma() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__rotateGamma}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_rotateGamma}}{\emph{coordVec}, \emph{angle}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftAfter() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftAfter}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftAfter}}{\emph{matrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{matrix}} (\emph{numpy.matrix}) -- sorts the matrix

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftAfterRotation() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftAfterRotation}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftAfterRotation}}{\emph{coordVec}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{coordVec}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftBeforeRotation() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftBeforeRotation}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftBeforeRotation}}{\emph{coordVec}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftCell() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftCell}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftCell}}{\emph{symMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftX}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftX}}{\emph{coordVec}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{coordVec}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftY}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftY}}{\emph{coordVec}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{coordVec}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_shiftZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__shiftZ}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_shiftZ}}{\emph{coordVec}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{coordVec}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_sortMatrix() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__sortMatrix}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_sortMatrix}}{\emph{matrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{matrix}} (\emph{numpy.matrix}) -- sorts the matrix

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{\_\_splitInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__splitInput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_splitInput}}{\emph{inFileString}}{}
Tokenizes the QE pwscf input file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{inFileString}} (\emph{str}) -- string of a QE pwscf input file

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{inputDict} --
the tokenized input

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeEfermi() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__writeEfermi}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_writeEfermi}}{\emph{oneCalc}, \emph{ID}}{}
Grabs the fermi enery or HOMO energy from the output files of the dos calculations
and converts into rydberg then writes it to file \textless{}ID\textgreater{}.efermi
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeInputFromOutput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__writeInputFromOutput}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_writeInputFromOutput}}{\emph{oneCalc}, \emph{ID}, \emph{replace=False}}{}
Writes an input file of that step updated with the positions and lattice vectors of its output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{replace} (\emph{bool}) --
if True then replace the input with the updated one

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeInputFromOutputString() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.__writeInputFromOutputString}\pysiglinewithargsret{\code{retr.}\bfcode{\_\_writeInputFromOutputString}}{\emph{oneCalc}, \emph{ID}}{}
Generates an input of that step updated with the positions and lattice vectors of its output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{newInput} --
string of that step's input updated with the positions and lattice vectors of its output

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{abc2celldm() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.abc2celldm}\pysiglinewithargsret{\code{retr.}\bfcode{abc2celldm}}{\emph{a=None}, \emph{b=None}, \emph{c=None}, \emph{alpha=None}, \emph{beta=None}, \emph{gamma=None}, \emph{ibrav=None}}{}
Convert a,b,c,alpha,beta,gamma into celldm for QE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\emph{float}) --
length of a

\item {} 
\textbf{b} (\emph{float}) --
length of b

\item {} 
\textbf{c} (\emph{float}) --
length of c

\item {} 
\textbf{alpha} (\emph{float}) --
Angle between axis b and c

\item {} 
\textbf{beta} (\emph{float}) --
Angle between axis a and c

\item {} 
\textbf{gamma} (\emph{float}) --
Angle between axis a and b

\item {} 
\textbf{ibrav} (\emph{int}) --
ibrav to be used to convert for defaults

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{celldm\_array} --
an array of (ibrav,celldm(1),celldm(2),celldm(3),celldm(4),celldm(5),celldm(6))

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{abc2free() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.abc2free}\pysiglinewithargsret{\code{retr.}\bfcode{abc2free}}{\emph{a=None}, \emph{b=None}, \emph{c=None}, \emph{alpha=None}, \emph{beta=None}, \emph{gamma=None}, \emph{ibrav=None}, \emph{returnString=True}}{}
Converts a,b,c,alpha,beta,gamma into QE convention primitive lattice vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\emph{float}) --
length of a

\item {} 
\textbf{b} (\emph{float}) --
length of b

\item {} 
\textbf{c} (\emph{float}) --
length of c

\item {} 
\textbf{alpha} (\emph{float}) --
Angle between axis b and c

\item {} 
\textbf{beta} (\emph{float}) --
Angle between axis a and c

\item {} 
\textbf{gamma} (\emph{float}) --
Angle between axis a and b

\item {} 
\textbf{ibrav} (\emph{int}) --
bravais lattice type by QE convention

\item {} 
\textbf{returnString} (\emph{bool}) --
return vectors as a string or as a numpy matrix

\end{itemize}

\item[{Returns}] \leavevmode
Either a numpy.matrix or a string of the primitive lattice vectors generated from the celldm input

\end{description}\end{quote}

\end{fulllineitems}

\index{abcVol() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.abcVol}\pysiglinewithargsret{\code{retr.}\bfcode{abcVol}}{\emph{a=None}, \emph{b=None}, \emph{c=None}, \emph{alpha=None}, \emph{beta=None}, \emph{gamma=None}, \emph{ibrav=None}}{}
Get volume from a,b,c,alpha,beta,gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{a} (\emph{float}) --
length of a

\item {} 
\textbf{b} (\emph{float}) --
length of b

\item {} 
\textbf{c} (\emph{float}) --
length of c

\item {} 
\textbf{alpha} (\emph{float}) --
Angle between axis b and c

\item {} 
\textbf{beta} (\emph{float}) --
Angle between axis a and c

\item {} 
\textbf{gamma} (\emph{float}) --
Angle between axis a and b

\item {} 
\textbf{ibrav} (\emph{int}) --
ibrav to be used to convert for defaults

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{cell\_vol} --
volume of the cell

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{attachPosFlags() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.attachPosFlags}\pysiglinewithargsret{\code{retr.}\bfcode{attachPosFlags}}{\emph{positionString}, \emph{flagString}}{}
Reattaches the flags to the end of the atomic position
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{positionString}} (\emph{str}) -- string of the atomic positions

\item {} 
\textbf{\texttt{flagString}} (\emph{str}) -- string of the flags

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{positionString} --
Positions with flags attached

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{celldm2abc() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.celldm2abc}\pysiglinewithargsret{\code{retr.}\bfcode{celldm2abc}}{\emph{ibrav=None}, \emph{celldm1=None}, \emph{celldm2=None}, \emph{celldm3=None}, \emph{celldm4=None}, \emph{celldm5=None}, \emph{celldm6=None}, \emph{cosine=True}, \emph{degrees=False}}{}
Convert celldm for espresso into A,B,C,and angles alpha,beta,gamma
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cellparamatrix}} (\emph{numpy.matrix}) -- matrix of cell vectors

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{cosine} (\emph{bool}) --
If True alpha,beta,gamma are cos(alpha),cos(beta),cos(gamma),

\item {} 
\textbf{degrees} (\emph{bool}) --
If True return alpha,beta,gamma in degrees; radians if False

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{paramArray} --
a list of the parameters a,b,c,alpha,beta,gamma generated from the input matrix

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{celldm2free() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.celldm2free}\pysiglinewithargsret{\code{retr.}\bfcode{celldm2free}}{\emph{ibrav=None}, \emph{celldm1=None}, \emph{celldm2=None}, \emph{celldm3=None}, \emph{celldm4=None}, \emph{celldm5=None}, \emph{celldm6=None}, \emph{returnString=True}}{}
Converts  QE's celldm format into QE convention primitive lattice vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{ibrav} (\emph{int}) --
bravais lattice type by QE convention

\item {} 
\textbf{celldm1} (\emph{float}) --
a

\item {} 
\textbf{celldm2} (\emph{float}) --
b/a

\item {} 
\textbf{celldm3} (\emph{float}) --
c/a

\item {} 
\textbf{celldm4} (\emph{float}) --
Cosine of the angle between axis b and c

\item {} 
\textbf{celldm5} (\emph{float}) --
Cosine of the angle between axis a and c

\item {} 
\textbf{celldm6} (\emph{float}) --
Cosine of the angle between axis a and b

\item {} 
\textbf{returnString} (\emph{bool}) --
return vectors as a string or as a numpy matrix

\end{itemize}

\item[{Returns}] \leavevmode
Either a numpy.matrix or a string of the primitive lattice vectors generated from the celldm input

\end{description}\end{quote}

\end{fulllineitems}

\index{celldm2params() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.celldm2params}\pysiglinewithargsret{\code{retr.}\bfcode{celldm2params}}{\emph{a}, \emph{b}, \emph{c}, \emph{alpha}, \emph{beta}, \emph{gamma}, \emph{k}, \emph{v}}{}
DEFUNCT \textless{}Marked for removal\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{checkStatus() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.checkStatus}\pysiglinewithargsret{\code{retr.}\bfcode{checkStatus}}{\emph{PROJECT}, \emph{SET='`}, \emph{config='`}, \emph{step=0}, \emph{status=\{\}}, \emph{negate\_status=False}}{}
function that loads the calclogs of each of the calculations in your run and
displays status information about them.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{PROJECT}} (\emph{str}) -- Project name

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{SET} (\emph{str}) --
Set name

\item {} 
\textbf{config} (\emph{str}) --
Config file used

\item {} 
\textbf{step} (\emph{int}) --
Which number step to seee (default all of them)

\item {} 
\textbf{status} (\emph{dict}) --
dictionary containing the status and the value
you want to see (ex. \{`Error':True\})

\item {} 
\textbf{negate\_status} (\emph{bool}) --
Whether to take the calculations with that status or without it

\end{itemize}

\item[{Returns}] \leavevmode
calcsList (list) list of each step of the calculations you
selected that satisfay the status criteria

\end{description}\end{quote}

\end{fulllineitems}

\index{chemAsKeys() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.chemAsKeys}\pysiglinewithargsret{\code{retr.}\bfcode{chemAsKeys}}{\emph{calcs}}{}
For sets of calcs that only differ by chemistry you can replace the
hash by the chemical name. May not always work. Especially if there
are two compounds with swapped positions of atoms of different elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{calcsCopy} --
returns new dictionay with keys as the chemical stoiciometry

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{compMatrices() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.compMatrices}\pysiglinewithargsret{\code{retr.}\bfcode{compMatrices}}{\emph{matrix1}, \emph{matrix2}}{}
Compare two numpy matrices to see if they are equal or not
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{matrix1}} (\emph{numpy.matrix}) -- first matrix

\item {} 
\textbf{\texttt{matrix2}} (\emph{numpy.matrix}) -- second matrix

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{equalBool} --
True if they're equal False if they're not

\item[{Return type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{convertFCC() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.convertFCC}\pysiglinewithargsret{\code{retr.}\bfcode{convertFCC}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{detachPosFlags() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.detachPosFlags}\pysiglinewithargsret{\code{retr.}\bfcode{detachPosFlags}}{\emph{positionString}}{}
Detach the position flags from the string of the atomic positions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{positionString}} (\emph{str}) -- string of the atomic positions

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{positions} --
atomic positions as a list
flags (list): a list of the flags for by each position

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{free2abc() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.free2abc}\pysiglinewithargsret{\code{retr.}\bfcode{free2abc}}{\emph{cellparamatrix}, \emph{cosine=True}, \emph{degrees=True}, \emph{string=True}, \emph{bohr=False}}{}
Convert lattice vectors to a,b,c,alpha,beta,gamma of the primitive lattice
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cellparamatrix}} (\emph{numpy.matrix}) -- matrix of cell vectors

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{cosine} (\emph{bool}) --
If True alpha,beta,gamma are cos(alpha),cos(beta),cos(gamma),

\item {} 
\textbf{degrees} (\emph{bool}) --
If True return alpha,beta,gamma in degrees; radians if False

\item {} 
\textbf{string} (\emph{bool}) --
If True return a,b,c,alpha,beta,gamma as a string; if False return as a list

\item {} 
\textbf{bohr} (\emph{bool}) --
If True return a,b,c in bohr radii; if False return in angstrom

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{paramArray} --
a list of the parameters a,b,c,alpha,beta,gamma generated from the input matrix

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{free2ibrav() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.free2ibrav}\pysiglinewithargsret{\code{retr.}\bfcode{free2ibrav}}{\emph{cellparamatrix}, \emph{ibrav=0}, \emph{primitive=True}}{}
Convert lattice vectors to celldm
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cellparamatrix}} (\emph{numpy.matrix}) -- matrix of cell vectors

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{ibrav} (\emph{int}) --
Overrides the bravais lattice automatically detected
(must be in QE convention if primitive)

\item {} 
\textbf{primitive} (\emph{bool}) --
If True it will treat cellparamatrix as primitive lattice vectors

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{ibravStr} --
string of the celldm used for QE pwscf input

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getBravaisLatticeName() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getBravaisLatticeName}\pysiglinewithargsret{\code{retr.}\bfcode{getBravaisLatticeName}}{\emph{bravaisLatticeNumber}}{}
Returns the name of the crystal system from the bravias lattice number
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{braviasLatticeNumber}} (\emph{int}) -- the number of the bravais lattice in QE convention

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
A string of the name of the crystal system

\end{description}\end{quote}

\end{fulllineitems}

\index{getCellMatrixFromInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getCellMatrixFromInput}\pysiglinewithargsret{\code{retr.}\bfcode{getCellMatrixFromInput}}{\emph{inputString}, \emph{string=False}, \emph{scale=True}}{}
Get the primitive cell vectors from the input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{string} (\emph{bool}) --
Return a string or matrix

\item {} 
\textbf{scale} (\emph{bool}) --
scale the vectors by alat

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{cellParamMatrix} --
primitive lattice params

\item[{Return type}] \leavevmode
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{getCellOutput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getCellOutput}\pysiglinewithargsret{\code{retr.}\bfcode{getCellOutput}}{\emph{oneCalc}, \emph{ID}}{}
retreives information about the structure and its chemistry and prints
it into a file in the AFLOWpi folder inside the project/set directories
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{outputStr} --
Output of the report for the calculation

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getCellVolume() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getCellVolume}\pysiglinewithargsret{\code{retr.}\bfcode{getCellVolume}}{\emph{oneCalc}, \emph{ID}, \emph{conventional=True}, \emph{string=True}}{}
Gets the cell volume from output if avaiable and if not gets it from the input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{conventional} (\emph{bool}) --
return the volume of the primitive or conventional lattice

\item {} 
\textbf{string} (\emph{bool}) --
to return as a string or as a float

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{vol} --
Volume of the cell

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getCellVolumeFromVectors() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getCellVolumeFromVectors}\pysiglinewithargsret{\code{retr.}\bfcode{getCellVolumeFromVectors}}{\emph{cellInput}}{}
Calculates cell volume from basis vectors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cellInput}} (\emph{numpy.matrix}) -- basis set defining the cell

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{vol} --
volume of the cell (may be not scaled. it depends on your input matrix)

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{getForce() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getForce}\pysiglinewithargsret{\code{retr.}\bfcode{getForce}}{\emph{oneCalc}, \emph{ID}}{}
Gets last entry of the total force in the calculation from the engine output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{force\_string} --
Total force from engine output

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{getIbravFromVectors() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getIbravFromVectors}\pysiglinewithargsret{\code{retr.}\bfcode{getIbravFromVectors}}{\emph{cellVectors}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{getPointGroup() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getPointGroup}\pysiglinewithargsret{\code{retr.}\bfcode{getPointGroup}}{\emph{oneCalc}, \emph{ID}, \emph{source='input'}}{}
NOT COMPLETED.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{source} (\emph{string}) --
either `input' or `output' to get point group from input
or output atomic positions

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{getPositionsFromInput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getPositionsFromInput}\pysiglinewithargsret{\code{retr.}\bfcode{getPositionsFromInput}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{getPositionsFromOutput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getPositionsFromOutput}\pysiglinewithargsret{\code{retr.}\bfcode{getPositionsFromOutput}}{\emph{oneCalc}, \emph{ID}}{}
Get the atomic positions from the output. If atomic positons can not be read from
output then the the positions from the input are returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{pos} --
atomic positions

\item[{Return type}] \leavevmode
numpy.matrix

\end{description}\end{quote}

\end{fulllineitems}

\index{getRecipParams() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.getRecipParams}\pysiglinewithargsret{\code{retr.}\bfcode{getRecipParams}}{\emph{oneCalc}}{}
reads the output from the SCF or relax calculation to get the
reciprocal cell parameters produced by the calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary of a single calculation

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{alat} --
alat multiplier
paramMatrix (numpy.matrix): matrix of reciprocal lattice vectors

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameters() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.get_parameters}\pysiglinewithargsret{\code{retr.}\bfcode{get\_parameters}}{\emph{oneCalc}, \emph{ID}, \emph{conventional=True}}{}
\end{fulllineitems}

\index{glideXshiftY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideXshiftY}\pysiglinewithargsret{\code{retr.}\bfcode{glideXshiftY}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{glideXshiftZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideXshiftZ}\pysiglinewithargsret{\code{retr.}\bfcode{glideXshiftZ}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{glideYshiftX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideYshiftX}\pysiglinewithargsret{\code{retr.}\bfcode{glideYshiftX}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{glideYshiftZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideYshiftZ}\pysiglinewithargsret{\code{retr.}\bfcode{glideYshiftZ}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{glideZshiftX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideZshiftX}\pysiglinewithargsret{\code{retr.}\bfcode{glideZshiftX}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{glideZshiftY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.glideZshiftY}\pysiglinewithargsret{\code{retr.}\bfcode{glideZshiftY}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}
\end{fulllineitems}

\index{grabEnergy() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.grabEnergy}\pysiglinewithargsret{\code{retr.}\bfcode{grabEnergy}}{\emph{oneCalc}, \emph{ID}}{}
Grabs energy for oneCalc and adds the keyword `Energy' with the value of the energy grabbed from the output
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode

\textbf{oneCalc} --
a dictionary containing properties about the AFLOWpi calculation
\begin{quote}

with the `Energy' keyword added
\end{quote}


\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{grabEnergyOut() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.grabEnergyOut}\pysiglinewithargsret{\code{retr.}\bfcode{grabEnergyOut}}{\emph{calcs}}{}
Goes in every subdirectory of the calculation and searches
for the final energy of the calculation and returns a new
copy of the input dictionary that includes the final energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{calcs} --
dictionary of dictionaries of calculations with energy added

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{ibrav2String() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.ibrav2String}\pysiglinewithargsret{\code{retr.}\bfcode{ibrav2String}}{\emph{ibrav=None}, \emph{celldm1=None}, \emph{celldm2=None}, \emph{celldm3=None}, \emph{celldm4=None}, \emph{celldm5=None}, \emph{celldm6=None}}{}
DEFUNCT \textless{}CONSIDER FOR REMOVAL\textgreater{}

Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{inputDict2params() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.inputDict2params}\pysiglinewithargsret{\code{retr.}\bfcode{inputDict2params}}{\emph{inputDict}}{}
Arguments:

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{invertX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.invertX}\pysiglinewithargsret{\code{retr.}\bfcode{invertX}}{\emph{symMatrix}, \emph{cellMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{invertXYZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.invertXYZ}\pysiglinewithargsret{\code{retr.}\bfcode{invertXYZ}}{\emph{symMatrix}, \emph{cellMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{invertY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.invertY}\pysiglinewithargsret{\code{retr.}\bfcode{invertY}}{\emph{symMatrix}, \emph{cellMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{invertZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.invertZ}\pysiglinewithargsret{\code{retr.}\bfcode{invertZ}}{\emph{symMatrix}, \emph{cellMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{pw2cif() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.pw2cif}\pysiglinewithargsret{\code{retr.}\bfcode{pw2cif}}{\emph{calcs}, \emph{inpt=True}, \emph{outp=True}, \emph{runlocal=False}, \emph{outputFolder=None}, \emph{filePrefix='`}}{}
Writes a simple CIF file for engine input and outputs for viewing the structure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{inpt} (\emph{bool}) --
Do CIF for input

\item {} 
\textbf{outp} (\emph{bool}) --
Do CIF for output

\item {} 
\textbf{outputFolder} (\emph{str}) --
Output directory for the CIF

\item {} 
\textbf{filePrefix} (\emph{str}) --
Optional prefix to the CIF filenames

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{rotateAlpha() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.rotateAlpha}\pysiglinewithargsret{\code{retr.}\bfcode{rotateAlpha}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{angle}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{rotateBeta() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.rotateBeta}\pysiglinewithargsret{\code{retr.}\bfcode{rotateBeta}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{angle}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{rotateGamma() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.rotateGamma}\pysiglinewithargsret{\code{retr.}\bfcode{rotateGamma}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{angle}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{shiftCell() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.shiftCell}\pysiglinewithargsret{\code{retr.}\bfcode{shiftCell}}{\emph{symMatrix}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{shiftX() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.shiftX}\pysiglinewithargsret{\code{retr.}\bfcode{shiftX}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{shiftY() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.shiftY}\pysiglinewithargsret{\code{retr.}\bfcode{shiftY}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{shiftZ() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.shiftZ}\pysiglinewithargsret{\code{retr.}\bfcode{shiftZ}}{\emph{symMatrix}, \emph{cellMatrix}, \emph{shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{symMatrix}} (\emph{numpy.matrix}) -- atomic positions in matrix form

\item {} 
\textbf{\texttt{cellMatrix}} (\emph{numpy.matrix}) -- primitive lattice vectors in matrix form

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{transform\_input\_conv() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.transform_input_conv}\pysiglinewithargsret{\code{retr.}\bfcode{transform\_input\_conv}}{\emph{oneCalc}, \emph{ID}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- a dictionary containing properties about the AFLOWpi calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID string for the particular calculation and step

\end{itemize}

\end{description}\end{quote}

Keyword Arguments:

Returns:

\end{fulllineitems}

\index{writeInputFromOutput() (in module retr)}

\begin{fulllineitems}
\phantomsection\label{retr:retr.writeInputFromOutput}\pysiglinewithargsret{\code{retr.}\bfcode{writeInputFromOutput}}{\emph{calcs}, \emph{replace=False}, \emph{runlocal=False}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{replace} (\emph{bool}) --
If true replace the input with updated atomic positions and cell parameters

\item {} 
\textbf{runlocal} (\emph{bool}) --
run local or write to \textless{}ID\textgreater{}.py

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\chapter{run module}
\label{run:module-run}\label{run::doc}\label{run:run-module}\index{run (module)}\index{\_\_PW\_bands\_fix() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__PW_bands_fix}\pysiglinewithargsret{\code{run.}\bfcode{\_\_PW\_bands\_fix}}{\emph{oneCalc}, \emph{ID}}{}
Accounts for the occational problem of the bands.x output being
improperly formatted for AFLOWpi to parse later.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_collect\_fd\_field\_forces() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__collect_fd_field_forces}\pysiglinewithargsret{\code{run.}\bfcode{\_\_collect\_fd\_field\_forces}}{\emph{oneCalc}, \emph{ID}, \emph{for\_type='raman'}}{}
Runs at the end of the scf calculations for the Finite Difference phonon
calculations. It uses regex to pull the forces to be saved to files for
parsing by fd\_ifc.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{for\_type} (\emph{str}) --
type of file to pull from in FD\_PHONON dir (choices are `raman', `born', `epol')

\item[{Returns}] \leavevmode
force\_out\_str (str) a string of the contents of the file

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_colorize\_message() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__colorize_message}\pysiglinewithargsret{\code{run.}\bfcode{\_\_colorize\_message}}{\emph{string}, \emph{level='ERROR'}, \emph{show\_level=True}}{}
Colorizes text. Used for colorizing the logging
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{string}} (\emph{str}) -- A string of text

\item[{Keyword Arguments}] \leavevmode
\textbf{level} (\emph{str}) --
Specific colors are chosen for logging message type

\item[{Returns}] \leavevmode
\textbf{levelname\_color} --
Colorized version of the string input

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_convert\_fortran\_double() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__convert_fortran_double}\pysiglinewithargsret{\code{run.}\bfcode{\_\_convert\_fortran\_double}}{\emph{fort\_double\_string}, \emph{string\_output=False}}{}
find the start time of current step in chain and record that into the walltime file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fort\_double\_string}} (\emph{str}) -- Fortran double in string form

\item[{Keyword Arguments}] \leavevmode
\textbf{string\_output} (\emph{bool}) --
Output a string or a float

\item[{Returns}] \leavevmode
\textbf{fort\_double\_string} --
the fotran double in float form or string

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_exitClean() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__exitClean}\pysiglinewithargsret{\code{run.}\bfcode{\_\_exitClean}}{\emph{signal}, \emph{frame}}{}
If the terminate 15 signal is received exit with 0 exit code
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{signal}} (\emph{signal.SIGNAL}) -- {\color{red}\bfseries{}*}nix signal

\item {} 
\textbf{\texttt{frame}} (\emph{frame}) -- Inspect frame

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_field\_factory() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__field_factory}\pysiglinewithargsret{\code{run.}\bfcode{\_\_field\_factory}}{\emph{input\_str}, \emph{field\_strength=0.001}, \emph{for\_type='raman'}, \emph{nberrycyc=3}, \emph{dir\_index=0}}{}
Modifies the QE pwscf input for the finite field calc of a given index
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{input\_str}} (\emph{str}) -- string of QE pwscf input file

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{feild\_strength} (\emph{float}) --
applied electric field strength

\item {} 
\textbf{nberrycyc (int) number of berry phase cycles}

\item {} 
\textbf{for\_type} (\emph{str}) --
which type of FD input do we want to generate files for. `raman','born','eps'

\item {} 
\textbf{dir\_index} (\emph{int}) --
index of the finite field direction to choose

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{new\_input} --
the modified input string

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_gen\_fd\_input() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__gen_fd_input}\pysiglinewithargsret{\code{run.}\bfcode{\_\_gen\_fd\_input}}{\emph{oneCalc}, \emph{ID}, \emph{for\_type='raman'}, \emph{de=0.003}}{}
Generates the input files for the finite field calcs from the input file string in oneCalc
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{for\_type} (\emph{str}) --
which type of FD input do we want to generate files for. `raman','born','eps'

\item {} 
\textbf{de} (\emph{float}) --
applied electric field strength

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_generic\_restart\_check() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__generic_restart_check}\pysiglinewithargsret{\code{run.}\bfcode{\_\_generic\_restart\_check}}{\emph{oneCalc}, \emph{ID}, \emph{\_\_submitNodeName\_\_}}{}
Checks to see if walltime limit is almost up. If it is within the buffer of time
The job is resubmitted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getEnginePath() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__getEnginePath}\pysiglinewithargsret{\code{run.}\bfcode{\_\_getEnginePath}}{\emph{engine}, \emph{calcType}}{}
Gives the name of the executable file for the ab initio engine
for a given type of calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{engine}} (\emph{str}) -- Ab initio engine being used

\item {} 
\textbf{\texttt{calcType}} (\emph{str}) -- Type of calculation to be done

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{execPath} --
the name of the executable for that engine for that calcType

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getExecutable() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__getExecutable}\pysiglinewithargsret{\code{run.}\bfcode{\_\_getExecutable}}{\emph{engine}, \emph{calcType}}{}
Gives the name of the executable file for the ab initio engine
for a given type of calculation.

OBSOLETE. NEEDS REMOVAL. AFLOWpi.run.\_\_getEnginePath is almost identical
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{engine}} (\emph{str}) -- Ab initio engine being used

\item {} 
\textbf{\texttt{calcType}} (\emph{str}) -- Type of calculation to be done

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{executable} --
the name of the executable for that engine for that calcType

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getWalltime() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__getWalltime}\pysiglinewithargsret{\code{run.}\bfcode{\_\_getWalltime}}{\emph{oneCalc}, \emph{ID}}{}
Get the walltime requested from the cluster submission script
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
walltime (int) amount of time requested

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_get\_index\_from\_pp\_step() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__get_index_from_pp_step}\pysiglinewithargsret{\code{run.}\bfcode{\_\_get\_index\_from\_pp\_step}}{\emph{oneCalc}, \emph{ID}}{}
DEFUNCT. CANDIDATE FOR REMOVAL
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{ID} --
Returns the input ID

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_get\_qsub\_name() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__get_qsub_name}\pysiglinewithargsret{\code{run.}\bfcode{\_\_get\_qsub\_name}}{\emph{path}}{}
Takes path of the cluster submission file and forms a name for the submission
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} (\emph{str}) -- path of the cluster job submission file

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{calcName} --
name of the calculation used with the submission

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_grabWalltime() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__grabWalltime}\pysiglinewithargsret{\code{run.}\bfcode{\_\_grabWalltime}}{\emph{oneCalc}, \emph{ID}}{}
find the start time of current step in chain and record that into the walltime file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{walltimeStart} --
walltime requested
startTime (int): start time of the script

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_io\_error\_restart() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__io_error_restart}\pysiglinewithargsret{\code{run.}\bfcode{\_\_io\_error\_restart}}{\emph{ID}, \emph{oneCalc}, \emph{\_\_submitNodeName\_\_}}{}
Restarts if I/O error encountered

BROKEN/NOT NEEDED POSSIBLY DELETE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_makeInput() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__makeInput}\pysiglinewithargsret{\code{run.}\bfcode{\_\_makeInput}}{\emph{oneCalc}, \emph{engine}, \emph{calcType}, \emph{ID='`}}{}
Writes the input file for postprocessing calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- Dictionary of one of the calculations

\item {} 
\textbf{\texttt{engine}} (\emph{str}) -- Particular engine executable being used for the postprocessing step
that you are calling to run the calculations (default='pw.x')

\item {} 
\textbf{\texttt{calcType}} (\emph{str}) -- Type of PP calculation to be done

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{ID} (\emph{str}) --
ID hash for the calculation. Needed for the filename (\textless{}ID\textgreater{}\_\textless{}calcType\textgreater{}.in)

\item[{Returns}] \leavevmode
\textbf{stringDict} --
Input string of the PP step

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_onePrep() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__onePrep}\pysiglinewithargsret{\code{run.}\bfcode{\_\_onePrep}}{\emph{oneCalc}, \emph{ID}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{engine='espresso'}, \emph{calcType='`}, \emph{alt\_ID=None}}{}
Prepares one calculation run an engine executable
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations (default='pw.x')

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run (ex. mpiexec nice -n 19 \textless{}executable\textgreater{})
(default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run (ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -npool 12 )
(default = None)

\item {} 
\textbf{calcType} (\emph{str}) --
used to prep for a particular type of calc (i.e. `scf','pdos'..etc)

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_oneRun() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__oneRun}\pysiglinewithargsret{\code{run.}\bfcode{\_\_oneRun}}{\emph{\_\_submitNodeName\_\_}, \emph{oneCalc}, \emph{ID}, \emph{execPrefix='`}, \emph{execPostfix='`}, \emph{engine='espresso'}, \emph{calcType=None}, \emph{executable=None}, \emph{execPath=None}, \emph{nextCalc=None}, \emph{nextConf=None}}{}
Run a single calculation in the dictionary with a specific engine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of the calculation

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- Identifying hash of the calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{calcType} (\emph{str}) --
used to pull the engine post processing executable to the calc dir
and to write the postprocessing input file if needed

\item {} 
\textbf{executable} (\emph{str}) --
if the executable has already been copied to the calc's directory
then use this to run the input \textless{}ID\textgreater{}.in

\item {} 
\textbf{execPath} (\emph{str}) --
path of the executable if needed

\item {} 
\textbf{nextCalc} (\emph{str}) --
DEFUNCT

\item {} 
\textbf{nextConf} (\emph{str}) --
DEFUNCT

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_phonon\_band\_path() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__phonon_band_path}\pysiglinewithargsret{\code{run.}\bfcode{\_\_phonon\_band\_path}}{\emph{oneCalc}, \emph{ID}}{}
Gets path for the cell between High Symmetry points in Brillouin Zone
and returns for to be part of matdyn.x input for the phonon dispersion
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{path} --
Path between High Symmetry points in Brillouin Zone

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_pp\_phonon() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__pp_phonon}\pysiglinewithargsret{\code{run.}\bfcode{\_\_pp\_phonon}}{\emph{\_\_submitNodeName\_\_}, \emph{oneCalc}, \emph{ID}, \emph{LOTO=True}, \emph{de=0.01}, \emph{raman=True}, \emph{field\_strength=0.001}}{}
Calls the executables for the post processing of the force
data generated by the scf calculations created by fd.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_pull\_born\_out() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__pull_born_out}\pysiglinewithargsret{\code{run.}\bfcode{\_\_pull\_born\_out}}{\emph{oneCalc}, \emph{ID}}{}
Runs at the end of the scf calculations for the Finite Difference phonon
calculations. It uses regex to pull the born effective charges to be saved
to files for use by matdyn.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
born\_string (str) string of the born eff. charges

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_pull\_eps\_out() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__pull_eps_out}\pysiglinewithargsret{\code{run.}\bfcode{\_\_pull\_eps\_out}}{\emph{oneCalc}, \emph{ID}}{}
Runs at the end of the scf calculations for the Finite Difference phonon
calculations. It uses regex to pull the eps\_0 to be saved to files for
use by matdyn.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{eps\_string} --
string of the eps

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_pull\_forces() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__pull_forces}\pysiglinewithargsret{\code{run.}\bfcode{\_\_pull\_forces}}{\emph{oneCalc}, \emph{ID}}{}
Runs at the end of the scf calculations for the Finite Difference phonon
calculations. It uses regex to pull the forces to be saved to files for
parsing by fd\_ifc.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_pull\_polarization() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__pull_polarization}\pysiglinewithargsret{\code{run.}\bfcode{\_\_pull\_polarization}}{\emph{oneCalc}, \emph{ID}}{}
Runs at the end of the scf calculations for the Finite Difference phonon
calculations. It uses regex to pull the forces to be saved to files for
parsing by fd\_ifc.x
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_qe\_\_pre\_run() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__qe__pre_run}\pysiglinewithargsret{\code{run.}\bfcode{\_\_qe\_\_pre\_run}}{\emph{oneCalc}, \emph{ID}, \emph{calcType}, \emph{\_\_submitNodeName\_\_}, \emph{engine}}{}
Performs the pre-run checks and restarts the cluster job if needed.
On local mode this gets skipped
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{calcType}} (\emph{str}) -- type of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
dictionary of one of the calculations
ID (str): ID of calculation

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_qsubGen() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__qsubGen}\pysiglinewithargsret{\code{run.}\bfcode{\_\_qsubGen}}{\emph{oneCalc}, \emph{ID}}{}
Generates the cluster job submission file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{qsubFileString} --
string of cluster submission file

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_readWalltimeLog() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__readWalltimeLog}\pysiglinewithargsret{\code{run.}\bfcode{\_\_readWalltimeLog}}{\emph{oneCalc}, \emph{ID}}{}
reads walltime log from oneCalc
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode

\textbf{walltimeLog} --
dictionary containing start time for AFLOWpi as well
\begin{quote}

as the requested walltime for the cluster job
\end{quote}


\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_recordDeath() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__recordDeath}\pysiglinewithargsret{\code{run.}\bfcode{\_\_recordDeath}}{\emph{signal}, \emph{frame}}{}
If the 15 signal to terminate the process is sent.
Record it in oneCalc{[}'\_\_status\_\_'{]}{[}'Error'{]}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{signal}} (\emph{signal.SIGNAL}) -- {\color{red}\bfseries{}*}nix signal

\item {} 
\textbf{\texttt{frame}} (\emph{frame}) -- Inspect frame

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_restartGIPAW() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__restartGIPAW}\pysiglinewithargsret{\code{run.}\bfcode{\_\_restartGIPAW}}{\emph{oneCalc}, \emph{ID}, \emph{a}, \emph{\_\_submitNodeName\_\_}}{}
If pw.x ends becuause it hit max\_seconds. set the input to restart the calculation
and resubmit the job
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{a}} (\emph{float}) -- Time that has passed since calculation has started

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_restartPW() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__restartPW}\pysiglinewithargsret{\code{run.}\bfcode{\_\_restartPW}}{\emph{oneCalc}, \emph{ID}, \emph{a}, \emph{\_\_submitNodeName\_\_}}{}
If pw.x ends becuause it hit max\_seconds. set the input to restart the calculation
and resubmit the job
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{a}} (\emph{float}) -- Time that has passed since calculation has started

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_restartScript() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__restartScript}\pysiglinewithargsret{\code{run.}\bfcode{\_\_restartScript}}{\emph{oneCalc}, \emph{ID}, \emph{PID}}{}
special script started when the \_\textless{}ID\textgreater{}.py script starts. reads the walltime in the qsub file and
resubmits and then exits if the time ran gets within 1 minute of the walltime requested.
Used for when the script is on the post processing stages and may happen to get killed by
the cluster daemon.

\end{fulllineitems}

\index{\_\_setStartTime() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__setStartTime}\pysiglinewithargsret{\code{run.}\bfcode{\_\_setStartTime}}{\emph{oneCalc}, \emph{ID}}{}
If this python script is the first to run in for AFLOWpi in a cluster job then
the start time will be recorded and stored in the oneCalc object with the key
``\_\_walltime\_dict\_\_'' and the values for the start time of the script and the
requested walltime.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{walltimeStart} --
walltime requested
startTime (int): start time of the script

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setupRestartGIPAW() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__setupRestartGIPAW}\pysiglinewithargsret{\code{run.}\bfcode{\_\_setupRestartGIPAW}}{\emph{oneCalc}, \emph{ID}}{}
Sets up GIPAW input with max\_seconds to it will cleanly exit if it
doesn't finish within the time limit of the cluster submission
walltime requested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
dictionary of one of the calculations
ID (str): ID of calculation

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setupRestartPW() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__setupRestartPW}\pysiglinewithargsret{\code{run.}\bfcode{\_\_setupRestartPW}}{\emph{oneCalc}, \emph{ID}, \emph{\_\_submitNodeName\_\_}}{}
Sets up pw.x input with max\_seconds to it will cleanly exit if it
doesn't finish within the time limit of the cluster submission
walltime requested.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
dictionary of one of the calculations
ID (str): ID of calculation

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_setup\_raman() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__setup_raman}\pysiglinewithargsret{\code{run.}\bfcode{\_\_setup\_raman}}{\emph{calc\_subset}, \emph{orig\_oneCalc}, \emph{field\_strength=0.001}, \emph{nberrycyc=3}, \emph{for\_type='raman'}}{}
Sets up the input files and the command to run the finite field calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calc\_subset}} (\emph{dict}) -- dictionary of dictionaries of the FD\_PHONON calculations

\item {} 
\textbf{\texttt{orig\_oneCalc}} (\emph{dict}) -- oneCalc of one calculation the main calc set

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{feild\_strength} (\emph{float}) --
applied electric field strength

\item {} 
\textbf{nberrycyc (int) number of berry phase cycles}

\item {} 
\textbf{for\_type} (\emph{str}) --
which type of FD input do we want to generate files for. `raman','born','eps'

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_skeletonRun() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__skeletonRun}\pysiglinewithargsret{\code{run.}\bfcode{\_\_skeletonRun}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up a custom calculation. Inputs and oneCalc calculation
dictionary must be created before calling this.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_submitJob() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__submitJob}\pysiglinewithargsret{\code{run.}\bfcode{\_\_submitJob}}{\emph{ID}, \emph{oneCalc}, \emph{\_\_submitNodeName\_\_}, \emph{sajOverride=False}, \emph{forceOneJob=False}}{}
Submits a step of a calculation's pipeline to be run
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{sajOverride} (\emph{bool}) --
Overrides stepsasjobs=False in the config file used

\item {} 
\textbf{forceOneJob} (\emph{bool}) --
Overrides stepsasjobs=True in the config file used

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_swap\_scf\_inputs() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__swap_scf_inputs}\pysiglinewithargsret{\code{run.}\bfcode{\_\_swap\_scf\_inputs}}{\emph{oneCalc}, \emph{ID}}{}
Swaps the value of oneCalc{[}'\_AFLOWPI\_INPUT\_'{]} in oneCalc to the finite field input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{oneCalc} --
dictionary of one of the calculations

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_testOne() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__testOne}\pysiglinewithargsret{\code{run.}\bfcode{\_\_testOne}}{\emph{ID}, \emph{oneCalc}, \emph{engine='`}, \emph{calcType='`}, \emph{execPrefix=None}, \emph{execPostfix=None}}{}
Stages the first the first step in a calculation workflow of a calc set to be submitted
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{calcType} (\emph{str}) --
used to pull the engine post processing executable to the calc dir
and to write the postprocessing input file if needed

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_vcrelax\_error\_restart() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__vcrelax_error_restart}\pysiglinewithargsret{\code{run.}\bfcode{\_\_vcrelax\_error\_restart}}{\emph{ID}, \emph{oneCalc}, \emph{\_\_submitNodeName\_\_}}{}
Restarts if vc-relax calculation fails

BROKEN/NOT NEEDED POSSIBLY DELETE
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_writeWalltimeLog() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.__writeWalltimeLog}\pysiglinewithargsret{\code{run.}\bfcode{\_\_writeWalltimeLog}}{\emph{oneCalc}, \emph{ID}, \emph{walltimeDict}}{}
Writes the walltimeDict to disk ( \_\textless{}ID\textgreater{}.oneCalc )
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\item {} 
\textbf{\texttt{walltimeDict}} (\emph{dict}) -- saves the walltime log to oneCalc and then to disk

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{\_fancy\_error\_log() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run._fancy_error_log}\pysiglinewithargsret{\code{run.}\bfcode{\_fancy\_error\_log}}{\emph{e}}{}
Logs an error and prints it out on the stdout if logging=debug in the config file used
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{e}} (\emph{str}) -- string of the error

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{addatexit\_\_() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.addatexit__}\pysiglinewithargsret{\code{run.}\bfcode{addatexit\_\_}}{\emph{command}, \emph{*args}, \emph{**kwargs}}{}
Wrapper to add function to be run at exit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{command}} (\emph{func}) -- function to be run

\item {} 
\textbf{\texttt{*args}} -- arguments for command

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{**kwargs} --
Keyword arguments for command

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{bands() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.bands}\pysiglinewithargsret{\code{run.}\bfcode{bands}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=' `}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up Electronic Band Structure calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{clean\_cell\_params() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.clean_cell_params}\pysiglinewithargsret{\code{run.}\bfcode{clean\_cell\_params}}{\emph{output}}{}
Parses the atomic shifts in a supercell from fd.x
outputted pw.x input files to correct for formatting
issues when they are imported to AFLOWpi
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{output}} (\emph{str}) -- pw.x input files generated by fd.x

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{output} --
pw.x input files generated by fd.x (cleaned by AFLOWpi)

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{cleanup() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.cleanup}\pysiglinewithargsret{\code{run.}\bfcode{cleanup}}{\emph{calcs}}{}
Deletes all files a calculation set's  directory
tree that are prepended with `\_'
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{dos() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.dos}\pysiglinewithargsret{\code{run.}\bfcode{dos}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up DOS nscf calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{emr() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.emr}\pysiglinewithargsret{\code{run.}\bfcode{emr}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up GIPAW EMR calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{generateSubRef() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.generateSubRef}\pysiglinewithargsret{\code{run.}\bfcode{generateSubRef}}{\emph{qsubRefFileString}, \emph{oneCalc}, \emph{ID}}{}
Reads in the reference cluster submission file specified in ``jobreffile''
in the config used. Tries to insert a few parameters.

OBSOLETE PLANNED FOR REMOVAL
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{qsubRefFileString}} (\emph{str}) -- string of the ``reference'' cluster submission file

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
\textbf{clusterTypeDict} --
string cluster submission file

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{gvectors() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.gvectors}\pysiglinewithargsret{\code{run.}\bfcode{gvectors}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up GIPAW gvectors calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{hyperfine() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.hyperfine}\pysiglinewithargsret{\code{run.}\bfcode{hyperfine}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}, \emph{isotope=()}}{}
Wrapper to set up GIPAW hyperfine calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{nmr() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.nmr}\pysiglinewithargsret{\code{run.}\bfcode{nmr}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up GIPAW NMR calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{pdos() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.pdos}\pysiglinewithargsret{\code{run.}\bfcode{pdos}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix='`}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up DOS projection calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{prep\_fd() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.prep_fd}\pysiglinewithargsret{\code{run.}\bfcode{prep\_fd}}{\emph{\_\_submitNodeName\_\_}, \emph{oneCalc}, \emph{ID}, \emph{nrx1=2}, \emph{nrx2=2}, \emph{nrx3=2}, \emph{innx=2}, \emph{de=0.01}, \emph{atom\_sym=True}, \emph{disp\_sym=True}}{}
Generates input files for fd.x, fd\_ifc.x, and matdyn.x for the finite
difference phonon calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{\_\_submitNodeName\_\_}} (\emph{str}) -- String of hostname that cluster jobs should be submitted from

\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{nrx1} (\emph{int}) --
supercell size for first primitive lattice vector

\item {} 
\textbf{nrx2} (\emph{int}) --
supercell size for second primitive lattice vector

\item {} 
\textbf{nrx3} (\emph{int}) --
supercell size for third primitive lattice vector

\item {} 
\textbf{innx} (\emph{int}) --
how many differernt shifts in each direction for
finite difference phonon calculation

\item {} 
\textbf{de} (\emph{float}) --
amount to shift the atoms for finite differences

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_logs() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.reset_logs}\pysiglinewithargsret{\code{run.}\bfcode{reset\_logs}}{\emph{calcs}}{}
Removes log files from AFLOWpi directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{resubmit() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.resubmit}\pysiglinewithargsret{\code{run.}\bfcode{resubmit}}{\emph{calcs}}{}
Stages loaded calculation set to be resubmitted on a cluster
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{scf() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.scf}\pysiglinewithargsret{\code{run.}\bfcode{scf}}{\emph{calcs}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Wrapper to set up self-consitent calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\item {} 
\textbf{holdFlag} (\emph{bool}) --
DEFUNCT. NEEDS REMOVAL

\item {} 
\textbf{config} (\emph{str}) --
DEFUNCT. NEEDS REMOVAL

\end{itemize}

\end{description}\end{quote}

Returns:

\end{fulllineitems}

\index{submit() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.submit}\pysiglinewithargsret{\code{run.}\bfcode{submit}}{}{}
sets global \_\_submit\_\_flag\_\_ so calculations will start when user script completes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{None}} -- 

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{submitFirstCalcs\_\_() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.submitFirstCalcs__}\pysiglinewithargsret{\code{run.}\bfcode{submitFirstCalcs\_\_}}{\emph{calcs}}{}
Submits the first step of a calculation's pipeline
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode
\textbf{None}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{testOne() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.testOne}\pysiglinewithargsret{\code{run.}\bfcode{testOne}}{\emph{calcs}, \emph{calcType='scf'}, \emph{engine='`}, \emph{execPrefix=None}, \emph{execPostfix=None}, \emph{holdFlag=True}, \emph{config=None}}{}
Run all the calculation in the dictionary with a specific engine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs}} (\emph{dict}) -- Dictionary of dictionaries of calculations

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{engine} (\emph{str}) --
executable that you are calling to run the calculations

\item {} 
\textbf{execPrefix} (\emph{str}) --
commands to go before the executable when run
(ex. mpiexec nice -n 19 \textless{}executable\textgreater{}) (default = None)

\item {} 
\textbf{execPostfix} (\emph{str}) --
commands to go after the executable when run
(ex. \textless{}execPrefix\textgreater{} \textless{}executable\textgreater{} -ndiag 12 -nimage 2) (default = None)

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_fdx\_template() (in module run)}

\begin{fulllineitems}
\phantomsection\label{run:run.write_fdx_template}\pysiglinewithargsret{\code{run.}\bfcode{write\_fdx\_template}}{\emph{oneCalc}, \emph{ID}, \emph{nrx1=2}, \emph{nrx2=2}, \emph{nrx3=2}, \emph{innx=2}, \emph{de=0.01}, \emph{atom\_sym=True}, \emph{disp\_sym=True}}{}
Generates input files for fd.x, fd\_ifc.x, and matdyn.x for the finite
difference phonon calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc}} (\emph{dict}) -- dictionary of one of the calculations

\item {} 
\textbf{\texttt{ID}} (\emph{str}) -- ID of calculation

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{nrx1} (\emph{int}) --
supercell size for first primitive lattice vector

\item {} 
\textbf{nrx2} (\emph{int}) --
supercell size for second primitive lattice vector

\item {} 
\textbf{nrx3} (\emph{int}) --
supercell size for third primitive lattice vector

\item {} 
\textbf{innx} (\emph{int}) --
how many differernt shifts in each direction for
finite difference phonon calculation

\item {} 
\textbf{de} (\emph{float}) --
amount to shift the atoms for finite differences

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}



\chapter{scfuj module}
\label{scfuj:module-scfuj}\label{scfuj::doc}\label{scfuj:scfuj-module}\index{scfuj (module)}\index{WanT\_bands() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.WanT_bands}\pysiglinewithargsret{\code{scfuj.}\bfcode{WanT\_bands}}{\emph{oneCalc}, \emph{ID=None}, \emph{eShift=10.0}, \emph{nbnd=None}}{}
Make input files for  WanT bands calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calc\_copy -{-} dictionary of dictionaries of calculations}} (\emph{-}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{WanT\_dos() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.WanT_dos}\pysiglinewithargsret{\code{scfuj.}\bfcode{WanT\_dos}}{\emph{oneCalc, ID=None, eShift=10.0, temperature=300.0, energy\_range={[}-10.0, 10.0{]}}}{}
Make input files for  WanT bands calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calc\_copy -{-} dictionary of dictionaries of calculations}} (\emph{-}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{WanT\_epsilon() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.WanT_epsilon}\pysiglinewithargsret{\code{scfuj.}\bfcode{WanT\_epsilon}}{\emph{oneCalc, ID=None, eShift=10.0, temperature=300.0, energy\_range={[}0.1, 12.5{]}}}{}
Make input files for  WanT bands calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calc\_copy -{-} dictionary of dictionaries of calculations}} (\emph{-}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_getPAOfilename() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.__getPAOfilename}\pysiglinewithargsret{\code{scfuj.}\bfcode{\_\_getPAOfilename}}{\emph{atom}, \emph{PAOdir=None}}{}
Get the pseudopotential filename for the specific atomic species in input
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{atom -{-} a string designating the atomic species you want the pseudofile name for}} (\emph{-}) -- 

\item[{Keyword Arguments}] \leavevmode
\textbf{- pseudodir -- the path of the directory containing pseudofiles}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_\_oneMinimizeCalcs() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.__oneMinimizeCalcs}\pysiglinewithargsret{\code{scfuj.}\bfcode{\_\_oneMinimizeCalcs}}{\emph{oneCalc}, \emph{ID}, \emph{config=None}, \emph{pThresh=10.0}}{}
Get equilibrium volume using evfit to Murnaghan's EOS with 5 volumes in +/-20\% of input volume

\end{fulllineitems}

\index{\_\_oneScfprep() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.__oneScfprep}\pysiglinewithargsret{\code{scfuj.}\bfcode{\_\_oneScfprep}}{\emph{oneCalc}, \emph{ID}, \emph{paodir=None}}{}
Read a ref file (str), the dictionary defining the calculations, and the dictionary with the aflowkeys Create the dir
tree for the run and return a dictionary dictAllcalcs with all the calculations. Store the dictionary in a log file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{allAFLOWpiVars -{-} all the variables that you want to make a list of combinations of calculations from}} (\emph{-}) -- 

\item {} 
\textbf{\texttt{refFile    -{-} string that contains the input ref file file path}} (\emph{-}) -- 

\end{itemize}

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{- pseudodir  -- path of the directory that contains your Pseudopotential files}

\item {} 
\textbf{- paodir     -- path of the directory that contains pseudo atomic orbital files for the respective pseudo-potentials}

\item {} 
\textbf{- calcs      -- Dictionary of dictionaries of calculations - this can be empty if it is the initial acbn0 run.}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{acbn0() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.acbn0}\pysiglinewithargsret{\code{scfuj.}\bfcode{acbn0}}{\emph{oneCalc}, \emph{projCalcID}, \emph{byAtom=False}}{}
\end{fulllineitems}

\index{checkOscillation() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.checkOscillation}\pysiglinewithargsret{\code{scfuj.}\bfcode{checkOscillation}}{\emph{ID}, \emph{oneCalc}, \emph{uThresh=0.001}}{}
\end{fulllineitems}

\index{chkSpinCalc() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.chkSpinCalc}\pysiglinewithargsret{\code{scfuj.}\bfcode{chkSpinCalc}}{\emph{oneCalc}, \emph{ID=None}}{}
Check whether an calculation is spin polarized or not.

Arguments:

--oneCalc : dictionary of a single calculation.

\end{fulllineitems}

\index{chk\_species() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.chk_species}\pysiglinewithargsret{\code{scfuj.}\bfcode{chk\_species}}{\emph{elm}}{}
\end{fulllineitems}

\index{evCurveMinimize() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.evCurveMinimize}\pysiglinewithargsret{\code{scfuj.}\bfcode{evCurveMinimize}}{\emph{calcs}, \emph{config=None}, \emph{pThresh=10.0}, \emph{final\_minimization='vc-relax'}}{}
\end{fulllineitems}

\index{getU\_frmACBN0out() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.getU_frmACBN0out}\pysiglinewithargsret{\code{scfuj.}\bfcode{getU\_frmACBN0out}}{\emph{oneCalc}, \emph{ID}, \emph{byAtom=False}}{}
\end{fulllineitems}

\index{maketree() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.maketree}\pysiglinewithargsret{\code{scfuj.}\bfcode{maketree}}{\emph{oneCalc}, \emph{ID}, \emph{paodir=None}}{}
Make the directoy tree and place in the input file there
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{calcs -{-} Dictionary of dictionaries of calculations}} (\emph{-}) -- 

\item[{Keyword Arguments}] \leavevmode\begin{itemize}
\item {} 
\textbf{- pseudodir   -- path of pseudopotential files directory}

\item {} 
\textbf{- paodir       - path of pseudoatomic orbital basis set}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{nscf\_nosym\_noinv() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.nscf_nosym_noinv}\pysiglinewithargsret{\code{scfuj.}\bfcode{nscf\_nosym\_noinv}}{\emph{oneCalc}, \emph{ID=None}, \emph{kpFactor=1.5}}{}
Add the ncsf input to each subdir and update the master dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{calc\_copy -{-} dictionary of one calculation}} (\emph{-}) -- 

\item {} 
\textbf{\texttt{kpFactor -{-} multiplicative factor for kpoints from SCF to DOS (default}} (\emph{-}) -- \begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\end{enumerate}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{projwfc() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.projwfc}\pysiglinewithargsret{\code{scfuj.}\bfcode{projwfc}}{\emph{oneCalc}, \emph{ID=None}}{}
Run projwfc on each calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{oneCalc -{-} dictionary of a single calculation}} (\emph{-}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.run}\pysiglinewithargsret{\code{scfuj.}\bfcode{run}}{\emph{calcs}, \emph{uThresh=0.001}, \emph{nIters=20}, \emph{mixing=0.0}}{}
\end{fulllineitems}

\index{run\_transport() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.run_transport}\pysiglinewithargsret{\code{scfuj.}\bfcode{run\_transport}}{\emph{\_\_submitNodeName\_\_}, \emph{oneCalc}, \emph{ID}, \emph{run\_scf=True}, \emph{run\_transport\_prep=True}, \emph{run\_bands=True}, \emph{epsilon=True}, \emph{temperature=300}}{}
\end{fulllineitems}

\index{scfprep() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.scfprep}\pysiglinewithargsret{\code{scfuj.}\bfcode{scfprep}}{\emph{calcs}, \emph{paodir=None}}{}
\end{fulllineitems}

\index{transport\_prep() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.transport_prep}\pysiglinewithargsret{\code{scfuj.}\bfcode{transport\_prep}}{\emph{oneCalc}, \emph{ID}}{}
sets up the environment do do scf-\textgreater{}nscf-\textgreater{}projwfc to get overlap for transport calcs

\end{fulllineitems}

\index{updateUvals() (in module scfuj)}

\begin{fulllineitems}
\phantomsection\label{scfuj:scfuj.updateUvals}\pysiglinewithargsret{\code{scfuj.}\bfcode{updateUvals}}{\emph{oneCalc}, \emph{Uvals}, \emph{ID=None}}{}
Modify scf input file to do a lda+u calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{oneCalc      -{-} Dictionary of one calculation}} (\emph{-}) -- 

\item {} 
\textbf{\texttt{Uvals        -{-} Dictionary of Uvals}} (\emph{-}) -- 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{plot}}, \pageref{plot:module-plot}
\item {\texttt{prep}}, \pageref{prep:module-prep}
\item {\texttt{pseudo}}, \pageref{pseudo:module-pseudo}
\indexspace
\bigletter{r}
\item {\texttt{retr}}, \pageref{retr:module-retr}
\item {\texttt{run}}, \pageref{run:module-run}
\indexspace
\bigletter{s}
\item {\texttt{scfuj}}, \pageref{scfuj:module-scfuj}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
